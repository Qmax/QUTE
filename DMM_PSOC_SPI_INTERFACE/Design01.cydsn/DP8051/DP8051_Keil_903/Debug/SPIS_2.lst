C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 1   


C51 COMPILER V9.03, COMPILATION OF MODULE SPIS_2
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_903\Debug\SPIS_2.obj
COMPILER INVOKED BY: C:\Program Files\Cypress\PSoC Creator\2.0\PSoC Creator\import\keil\pk51\9.03\C51\BIN\c51.exe .\Gene
                    -rated_Source\PSoC3\SPIS_2.c NOIV LARGE MODDP2 OMF2 VB(1) PR(.\DP8051\DP8051_Keil_903\Debug\SPIS_2.lst) CD DB NOIP OT(2,S
                    -IZE) INCDIR(Generated_Source\PSoC3) OJ(.\DP8051\DP8051_Keil_903\Debug\SPIS_2.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: SPIS_2.c
   3          * Version 2.20
   4          *
   5          * Description:
   6          *  This file provides all API functionality of the SPI Slave component.
   7          *
   8          * Note:
   9          *  None.
  10          *
  11          ********************************************************************************
  12          * Copyright 2008-2011, Cypress Semiconductor Corporation.  All rights reserved.
  13          * You may use this file only in accordance with the license, terms, conditions,
  14          * disclaimers, and limitations in the end user license agreement accompanying
  15          * the software package with which this file was provided.
  16          *******************************************************************************/
  17          
  18          #include "CyLib.h"
  19          #include "SPIS_2.h"
  20          
  21          #if (SPIS_2_TXBUFFERSIZE > 4u)
              
                  volatile uint8 SPIS_2_TXBUFFER[SPIS_2_TXBUFFERSIZE] = {0u};
                  volatile uint8 SPIS_2_txBufferRead = 0u;
                  volatile uint8 SPIS_2_txBufferWrite = 0u;
                  volatile uint8 SPIS_2_txBufferFull = 0u;
              
              #endif /* SPIS_2_TXBUFFERSIZE > 4u */
  29          
  30          #if (SPIS_2_RXBUFFERSIZE > 4u)
              
                  volatile uint8 SPIS_2_RXBUFFER[SPIS_2_RXBUFFERSIZE] = {0u};
                  volatile uint8 SPIS_2_rxBufferRead = 0u;
                  volatile uint8 SPIS_2_rxBufferWrite = 0u;
                  volatile uint8 SPIS_2_rxBufferFull = 0u;
              
              #endif /* SPIS_2_RXBUFFERSIZE > 4u */
  38          
  39          uint8 SPIS_2_initVar = 0u;
  40          
  41          extern volatile uint8 SPIS_2_swStatusTx;
  42          extern volatile uint8 SPIS_2_swStatusRx;
  43          
  44          
  45          /*******************************************************************************
  46          * Function Name: SPIS_2_Init
  47          ********************************************************************************
  48          *
  49          * Summary:
  50          *  Inits/Restores default SPIS configuration provided with customizer.
  51          *
  52          * Parameters:
  53          *  None.
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 2   

  54          *
  55          * Return:
  56          *  None.
  57          *
  58          * Side Effects:
  59          *  When this function is called it initializes all of the necessary parameters
  60          *  for execution. i.e. setting the initial interrupt mask, configuring the
  61          *  interrupt service routine, configuring the bit-counter parameters and
  62          *  clearing the FIFO and Status Register.
  63          *
  64          * Reentrant:
  65          *  No.
  66          *
  67          *******************************************************************************/
  68          void SPIS_2_Init(void)
  69          {
  70   1          /*Initialize the Bit counter */
  71   1          SPIS_2_COUNTER_PERIOD_REG = SPIS_2_BITCTR_INIT;
  72   1      
  73   1          /* ISR initialization */
  74   1          #if(SPIS_2_InternalTxInterruptEnabled)
              
                      CyIntDisable(SPIS_2_TX_ISR_NUMBER);
              
                      /* Set the ISR to point to the SPIS_2_isr Interrupt. */
                      CyIntSetVector(SPIS_2_TX_ISR_NUMBER, SPIS_2_TX_ISR);
              
                      /* Set the priority. */
                      CyIntSetPriority(SPIS_2_TX_ISR_NUMBER, SPIS_2_TX_ISR_PRIORITY);
              
                  #endif /* SPIS_2_InternalTxInterruptEnabled */
  85   1      
  86   1          #if(SPIS_2_InternalRxInterruptEnabled)
              
                      CyIntDisable(SPIS_2_RX_ISR_NUMBER);
              
                      /* Set the ISR to point to the SPIS_2_isr Interrupt. */
                      CyIntSetVector(SPIS_2_RX_ISR_NUMBER, SPIS_2_RX_ISR);
              
                      /* Set the priority. */
                      CyIntSetPriority(SPIS_2_RX_ISR_NUMBER, SPIS_2_RX_ISR_PRIORITY);
              
                  #endif /* SPIS_2_InternalRxInterruptEnabled */
  97   1      
  98   1          /* Clear any stray data from the RX and TX FIFO */
  99   1          SPIS_2_ClearFIFO();
 100   1      
 101   1          #if(SPIS_2_RXBUFFERSIZE > 4u)
              
                      SPIS_2_rxBufferRead = 0u;
                      SPIS_2_rxBufferWrite = 0u;
              
                  #endif /* SPIS_2_RXBUFFERSIZE > 4u */
 107   1      
 108   1          #if(SPIS_2_TXBUFFERSIZE > 4u)
              
                      SPIS_2_txBufferRead = 0u;
                      SPIS_2_txBufferWrite = 0u;
              
                  #endif /* SPIS_2_TXBUFFERSIZE > 4u */
 114   1      
 115   1          (void) SPIS_2_ReadTxStatus(); /* Clear any pending status bits */
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 3   

 116   1          (void) SPIS_2_ReadRxStatus(); /* Clear any pending status bits */
 117   1      
 118   1      
 119   1          /* Configure the Initial interrupt mask */
 120   1          #if (SPIS_2_TXBUFFERSIZE > 4u)
                      SPIS_2_TX_STATUS_MASK_REG  = SPIS_2_TX_INIT_INTERRUPTS_MASK &
                                                              ~SPIS_2_STS_TX_FIFO_NOT_FULL;
                  #else /* SPIS_2_TXBUFFERSIZE < 4u */
 124   1              SPIS_2_TX_STATUS_MASK_REG  = SPIS_2_TX_INIT_INTERRUPTS_MASK;
 125   1          #endif /* SPIS_2_TXBUFFERSIZE > 4u */
 126   1      
 127   1          SPIS_2_RX_STATUS_MASK_REG  = SPIS_2_RX_INIT_INTERRUPTS_MASK;
 128   1      
 129   1      }
 130          
 131          
 132          /*******************************************************************************
 133          * Function Name: SPIS_2_Enable
 134          ********************************************************************************
 135          *
 136          * Summary:
 137          *  Enable SPIS component.
 138          *
 139          * Parameters:
 140          *  None.
 141          *
 142          * Return:
 143          *  None.
 144          *
 145          *******************************************************************************/
 146          void SPIS_2_Enable(void) 
 147          {
 148   1          uint8 enableInterrupts = 0u;
 149   1      
 150   1          enableInterrupts = CyEnterCriticalSection();
 151   1      
 152   1          SPIS_2_COUNTER_CONTROL_REG |= SPIS_2_CNTR_ENABLE;
 153   1          SPIS_2_TX_STATUS_ACTL_REG |= SPIS_2_INT_ENABLE;
 154   1          SPIS_2_RX_STATUS_ACTL_REG |= SPIS_2_INT_ENABLE;
 155   1      
 156   1          CyExitCriticalSection(enableInterrupts);
 157   1      
 158   1          #if(SPIS_2_InternalTxInterruptEnabled)
                      CyIntEnable(SPIS_2_TX_ISR_NUMBER);
                  #endif /* SPIS_2_InternalTxInterruptEnabled */
 161   1      
 162   1          #if(SPIS_2_InternalRxInterruptEnabled)
                      CyIntEnable(SPIS_2_RX_ISR_NUMBER);
                  #endif /* SPIS_2_InternalRxInterruptEnabled */
 165   1      }
 166          
 167          
 168          /*******************************************************************************
 169          * Function Name: SPIS_2_Start
 170          ********************************************************************************
 171          *
 172          * Summary:
 173          *  Initialize and Enable the SPI Slave component.
 174          *
 175          * Parameters:
 176          *  None.
 177          *
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 4   

 178          * Return:
 179          *  None.
 180          *
 181          * Global variables:
 182          *  SPIS_2_initVar - used to check initial configuration, modified on
 183          *  first function call.
 184          *
 185          * Theory:
 186          *  Enable the clock input to enable operation.
 187          *
 188          * Reentrant:
 189          *  No.
 190          *
 191          *******************************************************************************/
 192          void SPIS_2_Start(void)
 193          {
 194   1          if(SPIS_2_initVar == 0u)
 195   1          {
 196   2              SPIS_2_Init();
 197   2              SPIS_2_initVar = 1u;
 198   2          }
 199   1      
 200   1          SPIS_2_Enable();
 201   1      }
 202          
 203          
 204          /*******************************************************************************
 205          * Function Name: SPIS_2_Stop
 206          ********************************************************************************
 207          *
 208          * Summary:
 209          *  Disable the SPI Slave component.
 210          *
 211          * Parameters:
 212          *  None.
 213          *
 214          * Return:
 215          *  None.
 216          *
 217          * Theory:
 218          *  Disable the internal interrupt if one is used.
 219          *
 220          *******************************************************************************/
 221          void SPIS_2_Stop(void) 
 222          {
 223   1          uint8 enableInterrupts = 0u;
 224   1      
 225   1          enableInterrupts = CyEnterCriticalSection();
 226   1      
 227   1          SPIS_2_TX_STATUS_ACTL_REG &= ~SPIS_2_INT_ENABLE;
 228   1          SPIS_2_RX_STATUS_ACTL_REG &= ~SPIS_2_INT_ENABLE;
 229   1      
 230   1          CyExitCriticalSection(enableInterrupts);
 231   1      
 232   1          #if(SPIS_2_InternalTxInterruptEnabled)
                      CyIntDisable(SPIS_2_TX_ISR_NUMBER);
                  #endif /* SPIS_2_InternalTxInterruptEnabled */
 235   1      
 236   1          #if(SPIS_2_InternalRxInterruptEnabled)
                      CyIntDisable(SPIS_2_RX_ISR_NUMBER);
                  #endif /* SPIS_2_InternalRxInterruptEnabled */
 239   1      }
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 5   

 240          
 241          
 242          /*******************************************************************************
 243          * Function Name: SPIS_2_EnableTxInt
 244          ********************************************************************************
 245          *
 246          * Summary:
 247          *  Enable internal Tx interrupt generation.
 248          *
 249          * Parameters:
 250          *  None.
 251          *
 252          * Return:
 253          *  None.
 254          *
 255          * Theory:
 256          *  Enable the internal Tx interrupt output -or- the interrupt component itself.
 257          *
 258          *******************************************************************************/
 259          void SPIS_2_EnableTxInt(void) 
 260          {
 261   1          #if(SPIS_2_InternalTxInterruptEnabled)
                      CyIntEnable(SPIS_2_TX_ISR_NUMBER);
                  #endif /* SPIS_2_InternalTxInterruptEnabled */
 264   1      }
 265          
 266          
 267          /*******************************************************************************
 268          * Function Name: SPIS_2_EnableRxInt
 269          ********************************************************************************
 270          *
 271          * Summary:
 272          *  Enable internal Rx interrupt generation.
 273          *
 274          * Parameters:
 275          *  None.
 276          *
 277          * Return:
 278          *  None.
 279          *
 280          * Theory:
 281          *  Enable the internal Rx interrupt output -or- the interrupt component itself.
 282          *
 283          *******************************************************************************/
 284          void SPIS_2_EnableRxInt(void) 
 285          {
 286   1          #if(SPIS_2_InternalRxInterruptEnabled)
                      CyIntEnable(SPIS_2_RX_ISR_NUMBER);
                  #endif /* SPIS_2_InternalRxInterruptEnabled */
 289   1      }
 290          
 291          
 292          /*******************************************************************************
 293          * Function Name: SPIS_2_DisableTxInt
 294          ********************************************************************************
 295          *
 296          * Summary:
 297          *  Disable internal Tx interrupt generation.
 298          *
 299          * Parameters:
 300          *  None.
 301          *
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 6   

 302          * Return:
 303          *  None.
 304          *
 305          * Theory:
 306          *  Disable the internal Tx interrupt output -or- the interrupt component itself.
 307          *
 308          *******************************************************************************/
 309          void SPIS_2_DisableTxInt(void) 
 310          {
 311   1          #if(SPIS_2_InternalTxInterruptEnabled)
                      CyIntDisable(SPIS_2_TX_ISR_NUMBER);
                  #endif /* SPIS_2_InternalTxInterruptEnabled */
 314   1      }
 315          
 316          
 317          /*******************************************************************************
 318          * Function Name: SPIS_2_DisableRxInt
 319          ********************************************************************************
 320          *
 321          * Summary:
 322          *  Disable internal Rx interrupt generation.
 323          *
 324          * Parameters:
 325          *  None.
 326          *
 327          * Return:
 328          *  None.
 329          *
 330          * Theory:
 331          *  Disable the internal Rx interrupt output -or- the interrupt component itself.
 332          *
 333          *******************************************************************************/
 334          void SPIS_2_DisableRxInt(void) 
 335          {
 336   1          #if(SPIS_2_InternalRxInterruptEnabled)
                      CyIntDisable(SPIS_2_RX_ISR_NUMBER);
                  #endif /* SPIS_2_InternalRxInterruptEnabled */
 339   1      }
 340          
 341          
 342          /*******************************************************************************
 343          * Function Name: SPIS_2_SetTxInterruptMode
 344          ********************************************************************************
 345          *
 346          * Summary:
 347          *  Configure which status bits trigger an interrupt event.
 348          *
 349          * Parameters:
 350          *  intSrc: An or'd combination of the desired status bit masks (defined in the
 351          *  header file).
 352          *
 353          * Return:
 354          *  None.
 355          *
 356          * Theory:
 357          *  Enables the output of specific status bits to the interrupt controller.
 358          *
 359          *******************************************************************************/
 360          void SPIS_2_SetTxInterruptMode(uint8 intSrc) 
 361          {
 362   1          SPIS_2_TX_STATUS_MASK_REG  = intSrc;
 363   1      }
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 7   

 364          
 365          
 366          /*******************************************************************************
 367          * Function Name: SPIS_2_SetRxInterruptMode
 368          ********************************************************************************
 369          *
 370          * Summary:
 371          *  Configure which status bits trigger an interrupt event.
 372          *
 373          * Parameters:
 374          *  intSrc: An or'd combination of the desired status bit masks (defined in the
 375          *  header file).
 376          *
 377          * Return:
 378          *  None.
 379          *
 380          * Theory:
 381          *  Enables the output of specific status bits to the interrupt controller.
 382          *
 383          *******************************************************************************/
 384          void SPIS_2_SetRxInterruptMode(uint8 intSrc) 
 385          {
 386   1          SPIS_2_RX_STATUS_MASK_REG  = intSrc;
 387   1      }
 388          
 389          
 390          /*******************************************************************************
 391          * Function Name: SPIS_2_ReadTxStatus
 392          ********************************************************************************
 393          *
 394          * Summary:
 395          *  Read the Tx status register for the component.
 396          *
 397          * Parameters:
 398          *  None.
 399          *
 400          * Return:
 401          *  Contents of the Tx status register.
 402          *
 403          * Global variables:
 404          *  SPIS_2_swStatusTx - used to store in software status register,
 405          *  modified every function call - resets to zero.
 406          *
 407          * Theory:
 408          *  Allows the user and the API to read the Tx status register for error
 409          *  detection and flow control.
 410          *
 411          * Side Effects:
 412          *  Clear Tx status register of the component.
 413          *
 414          * Reentrant:
 415          *  No.
 416          *
 417          *******************************************************************************/
 418          uint8 SPIS_2_ReadTxStatus(void)
 419          {
 420   1          uint8 tmpStatus = 0u;
 421   1      
 422   1          #if (SPIS_2_TXBUFFERSIZE > 4u)
              
                      SPIS_2_DisableTxInt();
              
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 8   

                      tmpStatus = SPIS_2_GET_STATUS_TX(SPIS_2_swStatusTx);
              
                      SPIS_2_swStatusTx = 0u;
              
                      /* Enable Interrupts */
                      SPIS_2_EnableTxInt();
              
                  #else /* (SPIS_2_TXBUFFERSIZE < 4u) */
 434   1      
 435   1              tmpStatus = SPIS_2_TX_STATUS_REG;
 436   1      
 437   1          #endif /* (SPIS_2_TXBUFFERSIZE > 4u) */
 438   1      
 439   1          return(tmpStatus);
 440   1      }
 441          
 442          
 443          /*******************************************************************************
 444          * Function Name: SPIS_2_ReadRxStatus
 445          ********************************************************************************
 446          *
 447          * Summary:
 448          *  Read the Rx status register for the component.
 449          *
 450          * Parameters:
 451          *  None.
 452          *
 453          * Return:
 454          *  Contents of the Rx status register.
 455          *
 456          * Global variables:
 457          *  SPIS_2_swStatusRx - used to store in software Rx status register,
 458          *  modified every function call - resets to zero.
 459          *
 460          * Theory:
 461          *  Allows the user and the API to read the Rx status register for error
 462          *  detection and flow control.
 463          *
 464          * Side Effects:
 465          *  Clear Rx status register of the component.
 466          *
 467          * Reentrant:
 468          *  No.
 469          *
 470          *******************************************************************************/
 471          uint8 SPIS_2_ReadRxStatus(void)
 472          {
 473   1          uint8 tmpStatus = 0u;
 474   1      
 475   1          #if (SPIS_2_RXBUFFERSIZE > 4u)
              
                      SPIS_2_DisableRxInt();
              
                      tmpStatus = SPIS_2_GET_STATUS_RX(SPIS_2_swStatusRx);
              
                      SPIS_2_swStatusRx = 0u;
              
                      /* Enable Interrupts */
                      SPIS_2_EnableRxInt();
              
                  #else /* (SPIS_2_RXBUFFERSIZE < 4u) */
 487   1      
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 9   

 488   1              tmpStatus = SPIS_2_RX_STATUS_REG;
 489   1      
 490   1          #endif /* (SPIS_2_RXBUFFERSIZE > 4u) */
 491   1      
 492   1          return(tmpStatus);
 493   1      }
 494          
 495          
 496          /*******************************************************************************
 497          * Function Name: SPIS_2_WriteTxData
 498          ********************************************************************************
 499          *
 500          * Summary:
 501          *  Write a byte of data to be sent across the SPI.
 502          *
 503          * Parameters:
 504          *  txDataByte: The data value to send across the SPI.
 505          *
 506          * Return:
 507          *  None.
 508          *
 509          * Global variables:
 510          *  SPIS_2_txBufferWrite - used for the account of the bytes which
 511          *  have been written down in the TX software buffer, modified every function
 512          *  call if TX Software Buffer is used.
 513          *  SPIS_2_txBufferRead - used for the account of the bytes which
 514          *  have been read from the TX software buffer.
 515          *  SPIS_2_TXBUFFER[SPIS_2_TXBUFFERSIZE] - used to store
 516          *  data to sending, modified every function call if TX Software Buffer is used.
 517          *
 518          * Theory:
 519          *  Allows the user to transmit any byte of data in a single transfer.
 520          *
 521          * Side Effects:
 522          *  If this function is called again before the previous byte is finished then
 523          *  the next byte will be appended to the transfer with no time between
 524          *  the byte transfers. Clear Tx status register of the component.
 525          *
 526          * Reentrant:
 527          *  No.
 528          *
 529          *******************************************************************************/
 530          void SPIS_2_WriteTxData(uint8 txData)
 531          {
 532   1          #if(SPIS_2_TXBUFFERSIZE > 4u)
              
                      int16 tmpTxBufferRead = 0u;
              
                      /* Block if buffer is full, so we don't overwrite. */
                      do
                      {
                          tmpTxBufferRead = SPIS_2_txBufferRead - 1u;
                          if (tmpTxBufferRead < 0u)
                          {
                              tmpTxBufferRead = SPIS_2_TXBUFFERSIZE - 1u;
                          }
                      } while(tmpTxBufferRead == SPIS_2_txBufferWrite);
              
                      /* Disable Interrupt to protect variables that could change on interrupt. */
                      SPIS_2_DisableTxInt();
              
                      SPIS_2_swStatusTx = SPIS_2_GET_STATUS_TX(SPIS_2_swStatusTx);
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 10  

              
                      if((SPIS_2_txBufferRead == SPIS_2_txBufferWrite) &&
                          ((SPIS_2_swStatusTx & SPIS_2_STS_TX_FIFO_NOT_FULL) != 0u))
                      {
                          /* Add directly to the FIFO. */
                          CY_SET_REG8(SPIS_2_TXDATA_PTR, txData);
                      }
                      else
                      {
                          /* Add to the software buffer. */
                          SPIS_2_txBufferWrite++;
                          if(SPIS_2_txBufferWrite >= SPIS_2_TXBUFFERSIZE)
                          {
                              SPIS_2_txBufferWrite = 0u;
                          }
                             
                          if(SPIS_2_txBufferWrite == SPIS_2_txBufferRead)
                          {
                              SPIS_2_txBufferRead++;
                              if(SPIS_2_txBufferRead >= SPIS_2_RXBUFFERSIZE)
                              {
                                  SPIS_2_txBufferRead = 0u;
                              }
                              SPIS_2_txBufferFull = 1u;
                          }
              
                          SPIS_2_TXBUFFER[SPIS_2_txBufferWrite] = txData;
                          
                          SPIS_2_TX_STATUS_MASK_REG |= SPIS_2_STS_TX_FIFO_NOT_FULL;
                      }                  
                             
                      /* Enable Interrupt. */
                      SPIS_2_EnableTxInt();
              
                  #else /* SPIS_2_TXBUFFERSIZE <= 4u */
 585   1      
 586   1              /* Block while FIFO is full */
 587   1              while((SPIS_2_TX_STATUS_REG & SPIS_2_STS_TX_FIFO_NOT_FULL) == 0u);
 588   1      
 589   1              /* Then write the byte */
 590   1              CY_SET_REG8(SPIS_2_TXDATA_PTR, txData);
 591   1      
 592   1          #endif /* SPIS_2_TXBUFFERSIZE > 4u */
 593   1      }
 594          
 595          #if(SPIS_2_ModeUseZero == 1u)
 596          
 597              /*******************************************************************************
 598              * Function Name: SPIS_2_WriteTxDataZero
 599              ********************************************************************************
 600              *
 601              * Summary:
 602              *  Write a byte zero of data to be sent across the SPI. This must be used in
 603              *  Mode 00 and 01 if the FIFO is empty and data is not being sent.
 604              *
 605              * Parameters:
 606              *  txDataByte: The data value to send across the SPI.
 607              *
 608              * Return:
 609              *  None.
 610              *
 611              * Theory:
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 11  

 612              *  Allows the user to transmit any byte of data in a single transfer. Clear
 613              *  status register of the component.
 614              *
 615              *******************************************************************************/
 616              void SPIS_2_WriteTxDataZero(uint8 txDataByte)
 617                                                  
 618              {
 619   1              CY_SET_REG8(SPIS_2_TXDATA_ZERO_PTR, txDataByte);
 620   1          }
 621          
 622          #endif /* (SPIS_2_ModeUseZero == 1u) */
 623          
 624          
 625          /*******************************************************************************
 626          * Function Name: SPIS_2_ReadRxData
 627          ********************************************************************************
 628          *
 629          * Summary:
 630          *  Read the next byte of data received across the SPI.
 631          *
 632          * Parameters:
 633          *  None.
 634          *
 635          * Return:
 636          *  The next byte of data read from the FIFO.
 637          *
 638          * Global variables:
 639          *  SPIS_2_rxBufferWrite - used for the account of the bytes which
 640          *  have been written down in the RX software buffer.
 641          *  SPIS_2_rxBufferRead - used for the account of the bytes which
 642          *  have been read from the RX software buffer, modified every function
 643          *  call if RX Software Buffer is used.
 644          *  SPIS_2_RXBUFFER[SPIS_2_RXBUFFERSIZE] - used to store
 645          *  received data.
 646          *
 647          * Theory:
 648          *  Allows the user to read a byte of data received.
 649          *
 650          * Side Effects:
 651          *  Will return invalid data if the FIFO is empty.  User should poll for FIFO
 652          *  empty status before calling Read function.
 653          *
 654          * Reentrant:
 655          *  No.
 656          *
 657          *******************************************************************************/
 658          uint8 SPIS_2_ReadRxData(void)
 659          {
 660   1          uint8 rxData = 0u;
 661   1      
 662   1          #if(SPIS_2_RXBUFFERSIZE > 4u)
              
                      /* Disable Interrupt to protect variables that could change on interrupt. */
                      SPIS_2_DisableRxInt();
              
                      if(SPIS_2_rxBufferRead != SPIS_2_rxBufferWrite)
                      {
                          if(SPIS_2_rxBufferFull == 0u)
                          {
                              SPIS_2_rxBufferRead++;
                              if(SPIS_2_rxBufferRead >= SPIS_2_RXBUFFERSIZE)
                              {
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 12  

                                  SPIS_2_rxBufferRead = 0u;
                              }
                          }
                          else
                          {
                              SPIS_2_rxBufferFull = 0u;
                          }
                      }
              
                      rxData = SPIS_2_RXBUFFER[SPIS_2_rxBufferRead];
              
                      /* Enable Interrupt. */
                      SPIS_2_EnableRxInt();
              
                  #else /* SPIS_2_RXBUFFERSIZE <= 4u */
 689   1      
 690   1              rxData = CY_GET_REG8(SPIS_2_RXDATA_PTR);
 691   1      
 692   1          #endif /* SPIS_2_RXBUFFERSIZE > 4u */
 693   1      
 694   1          return (rxData);
 695   1      
 696   1      }
 697          
 698          
 699          /*******************************************************************************
 700          * Function Name: SPIS_2_GetRxBufferSize
 701          ********************************************************************************
 702          *
 703          * Summary:
 704          *  Returns the number of bytes/words of data currently held in the RX buffer.
 705          *  If RX Software Buffer not used then function return 0 if FIFO empty or 1 if
 706          *  FIFO not empty. In another case function return size of RX Software Buffer.
 707          *
 708          * Parameters:
 709          *  None.
 710          *
 711          * Return:
 712          *  Integer count of the number of bytes/words in the RX buffer.
 713          *
 714          * Global variables:
 715          *  SPIS_2_rxBufferWrite - used for the account of the bytes which
 716          *  have been written down in the RX software buffer.
 717          *  SPIS_2_rxBufferRead - used for the account of the bytes which
 718          *  have been read from the RX software buffer.
 719          *
 720          * Theory:
 721          *  Allows the user to find out how full the RX Buffer is.
 722          *
 723          *******************************************************************************/
 724          uint8 SPIS_2_GetRxBufferSize(void) 
 725          {
 726   1          uint8 size = 0u;
 727   1      
 728   1          #if(SPIS_2_RXBUFFERSIZE > 4u)
              
                      /* Disable Interrupt to protect variables that could change on interrupt. */
                      SPIS_2_DisableRxInt();
              
                      if(SPIS_2_rxBufferRead == SPIS_2_rxBufferWrite)
                      {
                          size = 0u; /* No data in RX buffer */
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 13  

                      }
                      else if(SPIS_2_rxBufferRead < SPIS_2_rxBufferWrite)
                      {
                          size = (SPIS_2_rxBufferWrite - SPIS_2_rxBufferRead);
                      }
                      else
                      {
                          size = (SPIS_2_RXBUFFERSIZE - SPIS_2_rxBufferRead) + SPIS_2_rxBufferWrite;
                      }
              
                      /* Enable interrupt. */
                      SPIS_2_EnableRxInt();
              
                  #else /* SPIS_2_RXBUFFERSIZE > 4u */
 750   1      
 751   1              /* We can only know if there is data in the fifo. */
 752   1              size = ((SPIS_2_RX_STATUS_REG & SPIS_2_STS_RX_FIFO_NOT_EMPTY) == 
 753   1                       SPIS_2_STS_RX_FIFO_NOT_EMPTY) ? 1u : 0u;
 754   1      
 755   1          #endif /* SPIS_2_RXBUFFERSIZE > 4u */
 756   1      
 757   1          return (size);
 758   1      }
 759          
 760          
 761          /*******************************************************************************
 762          * Function Name: SPIS_2_GetTxBufferSize
 763          ********************************************************************************
 764          *
 765          * Summary:
 766          *  Returns the number of bytes/words of data currently held in the TX buffer.
 767          *  If TX Software Buffer not used then function return 0 - if FIFO empty, 1 - if
 768          *  FIFO not full, 4 - if FIFO full. In another case function return size of TX
 769          *  Software Buffer.
 770          *
 771          * Parameters:
 772          *  None.
 773          *
 774          * Return:
 775          *  Integer count of the number of bytes/words in the TX buffer.
 776          *
 777          * Global variables:
 778          *  SPIS_2_txBufferWrite - used for the account of the bytes which
 779          *  have been written down in the TX software buffer.
 780          *  SPIS_2_txBufferRead - used for the account of the bytes which
 781          *  have been read from the TX software buffer.
 782          *
 783          * Theory:
 784          *  Allows the user to find out how full the TX Buffer is.
 785          *
 786          * Side Effects:
 787          *  Clear status register of the component.
 788          *
 789          *******************************************************************************/
 790          uint8  SPIS_2_GetTxBufferSize(void) 
 791          {
 792   1          uint8 size = 0u;
 793   1      
 794   1          #if(SPIS_2_TXBUFFERSIZE > 4u)
              
                      /* Disable Interrupt to protect variables that could change on interrupt. */
                      SPIS_2_DisableTxInt();
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 14  

              
                      if(SPIS_2_txBufferRead == SPIS_2_txBufferWrite)
                      {
                          size = 0u;
                      }
                      else if(SPIS_2_txBufferRead < SPIS_2_txBufferWrite)
                      {
                          size = (SPIS_2_txBufferWrite - SPIS_2_txBufferRead);
                      }
                      else
                      {
                          size = (SPIS_2_TXBUFFERSIZE - SPIS_2_txBufferRead) + SPIS_2_txBufferWrite;
                      }
              
                      /* Enable Interrupt. */
                      SPIS_2_EnableTxInt();
              
                  #else /* SPIS_2_TXBUFFERSIZE <= 4u */
 816   1      
 817   1              size = SPIS_2_TX_STATUS_REG;
 818   1      
 819   1              /* Is the fifo is full. */
 820   1              if((size & SPIS_2_STS_TX_FIFO_EMPTY) == SPIS_2_STS_TX_FIFO_EMPTY)
 821   1              {
 822   2                  size = 0u;
 823   2              }
 824   1              else if((size & SPIS_2_STS_TX_FIFO_NOT_FULL) == SPIS_2_STS_TX_FIFO_NOT_FULL)
 825   1              {
 826   2                  size = 1u;
 827   2              }
 828   1              else
 829   1              {
 830   2                  size = 4u;
 831   2              }
 832   1      
 833   1          #endif /* SPIS_2_TXBUFFERSIZE > 4u */
 834   1      
 835   1          return (size);
 836   1      }
 837          
 838          
 839          /*******************************************************************************
 840          * Function Name: SPIS_2_ClearRxBuffer
 841          ********************************************************************************
 842          *
 843          * Summary:
 844          *  Clear the RX RAM buffer by setting the read and write pointers both to zero.
 845          *
 846          * Parameters:
 847          *  None.
 848          *
 849          * Return:
 850          *  None.
 851          *
 852          * Global variables:
 853          *  SPIS_2_rxBufferWrite - used for the account of the bytes which
 854          *  have been written down in the RX software buffer, modified every function
 855          *  call - resets to zero.
 856          *  SPIS_2_rxBufferRead - used for the account of the bytes which
 857          *  have been read from the RX software buffer, modified every function call -
 858          *  resets to zero.
 859          *
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 15  

 860          * Theory:
 861          *  Setting the pointers to zero makes the system believe there is no data to
 862          *  read and writing will resume at address 0 overwriting any data that may have
 863          *  remained in the RAM.
 864          *
 865          * Side Effects:
 866          *  Any received data not read from the RAM buffer will be lost when overwritten.
 867          *
 868          * Reentrant:
 869          *  No.
 870          *
 871          *******************************************************************************/
 872          void SPIS_2_ClearRxBuffer(void)
 873          {
 874   1          /* Clear Hardware RX FIFO */
 875   1          while((!(SPIS_2_RX_STATUS_REG & SPIS_2_STS_RX_FIFO_NOT_EMPTY)) == 0u)
 876   1          {
 877   2              CY_GET_REG8(SPIS_2_RXDATA_PTR);
 878   2          }
 879   1      
 880   1          #if(SPIS_2_RXBUFFERSIZE > 4u)
              
                      /* Disable interrupt to protect variables that could change on interrupt. */
                      SPIS_2_DisableRxInt();
              
                      SPIS_2_rxBufferRead = 0u;
                      SPIS_2_rxBufferWrite = 0u;
              
                      /* Enable interrupt. */
                      SPIS_2_EnableRxInt();
              
                  #endif /* SPIS_2_RXBUFFERSIZE > 4u */
 892   1      }
 893          
 894          
 895          /*******************************************************************************
 896          * Function Name: SPIS_2_ClearTxBuffer
 897          ********************************************************************************
 898          *
 899          * Summary:
 900          *  Clear the TX RAM buffer by setting the read and write pointers both to zero.
 901          *
 902          * Parameters:
 903          *  None.
 904          *
 905          * Return:
 906          *  None.
 907          *
 908          * Global variables:
 909          *  SPIS_2_txBufferWrite - used for the account of the bytes which
 910          *  have been written down in the TX software buffer, modified every function
 911          *  call - resets to zero.
 912          *  SPIS_2_txBufferRead - used for the account of the bytes which
 913          *  have been read from the TX software buffer, modified every function call -
 914          *  resets to zero.
 915          *
 916          * Theory:
 917          *  Setting the pointers to zero makes the system believe there is no data to
 918          *  read and writing will resume at address 0 overwriting any data that may have
 919          *  remained in the RAM.
 920          *
 921          * Side Effects:
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 16  

 922          *  Any data not yet transmitted from the RAM buffer will be lost when
 923          *  overwritten.
 924          *
 925          * Reentrant:
 926          *  No.
 927          *
 928          *******************************************************************************/
 929          void SPIS_2_ClearTxBuffer(void)
 930          {
 931   1          uint8 enableInterrupts = 0u;
 932   1      
 933   1          /* Clear Hardware TX FIFO */
 934   1          enableInterrupts = CyEnterCriticalSection();
 935   1      
 936   1          #if(SPIS_2_DataWidth <= 8u)
 937   1      
 938   1              /* Clear TX FIFO */
 939   1              SPIS_2_TX_AUX_CONTROL_DP0_REG |= SPIS_2_FIFO_CLR;
 940   1              SPIS_2_TX_AUX_CONTROL_DP0_REG &= ~SPIS_2_FIFO_CLR;
 941   1      
 942   1          #else
              
                      /* Clear TX FIFO */
                      SPIS_2_TX_AUX_CONTROL_DP0_REG |= SPIS_2_FIFO_CLR;
                      SPIS_2_TX_AUX_CONTROL_DP0_REG &= ~SPIS_2_FIFO_CLR;
                      SPIS_2_TX_AUX_CONTROL_DP1_REG |= SPIS_2_FIFO_CLR;
                      SPIS_2_TX_AUX_CONTROL_DP1_REG &= ~SPIS_2_FIFO_CLR;
              
                  #endif /* SPIS_2_DataWidth > 8u */
 951   1      
 952   1          CyExitCriticalSection(enableInterrupts);
 953   1      
 954   1          #if(SPIS_2_TXBUFFERSIZE > 4u)
              
                      /* Disable Interrupt to protect variables that could change on interrupt. */
                      SPIS_2_DisableTxInt();
              
                      SPIS_2_txBufferRead = 0u;
                      SPIS_2_txBufferWrite = 0u;
              
                      /* If Buffer is empty then disable TX FIFO status interrupt */
                      SPIS_2_TX_STATUS_MASK_REG &= ~SPIS_2_STS_TX_FIFO_NOT_FULL;
              
                      /* Enable Interrupt. */
                      SPIS_2_EnableTxInt();
              
                  #endif /* SPIS_2_TXBUFFERSIZE > 4u */
 969   1      }
 970          
 971          
 972          #if (SPIS_2_BidirectionalMode == 1u)
              
                  /*******************************************************************************
                  * Function Name: SPIS_2_TxEnable
                  ********************************************************************************
                  *
                  * Summary:
                  *  If the SPI Slave is configured to use a single bi-directional pin then this
                  *  will set the bi-directional pin to transmit.
                  *
                  * Parameters:
                  *  None.
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 17  

                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  void SPIS_2_TxEnable(void) 
                  {
                          SPIS_2_CONTROL_REG |= SPIS_2_CTRL_TX_SIGNAL_EN;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: SPIS_2_TxDisable
                  ********************************************************************************
                  *
                  * Summary:
                  *  If the SPI Slave is configured to use a single bi-directional pin then this
                  *  will set the bi-directional pin to receive.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  void SPIS_2_TxDisable(void) 
                  {
                          SPIS_2_CONTROL_REG &= ~SPIS_2_CTRL_TX_SIGNAL_EN;
                  }
              
              #endif /* SPIS_2_BidirectionalMode == 1u */
1016          
1017          
1018          /*******************************************************************************
1019          * Function Name: SPIS_2_PutArray
1020          ********************************************************************************
1021          *
1022          * Summary:
1023          *  Write available data from RAM/ROM to the TX buffer while space is available
1024          *  in the TX buffer. Keep trying until all data is passed to the TX buffer. If
1025          *  used Mode 00 or 01 before PutArray() function should be called
1026          *  WriteTxDataZero() function.
1027          *
1028          * Parameters:
1029          *  *buffer: Pointer to the location in RAM containing the data to send
1030          *  byteCount: The number of bytes to move to the transmit buffer.
1031          *
1032          * Return:
1033          *  None.
1034          *
1035          * Side Effects:
1036          *  Will stay in this routine until all data has been sent.  May get locked in
1037          *  this loop if data is not being initiated by the master if there is not
1038          *  enough room in the TX FIFO.
1039          *
1040          * Reentrant:
1041          *  No.
1042          *
1043          *******************************************************************************/
1044          void SPIS_2_PutArray(uint8 *buffer, uint8 byteCount)
1045          {
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 18  

1046   1          while(byteCount > 0u)
1047   1          {
1048   2              SPIS_2_WriteTxData(*buffer++);
1049   2              byteCount--;
1050   2          }
1051   1      }
1052          
1053          
1054          /*******************************************************************************
1055          * Function Name: SPIS_2_ClearFIFO
1056          ********************************************************************************
1057          *
1058          * Summary:
1059          *  Clear the RX and TX FIFO's of all data for a fresh start.
1060          *
1061          * Parameters:
1062          *  None.
1063          *
1064          * Return:
1065          *  None.
1066          *
1067          * Side Effects:
1068          *  Clear status register of the component.
1069          *
1070          *******************************************************************************/
1071          void SPIS_2_ClearFIFO(void) 
1072          {
1073   1          uint8 enableInterrupts = 0u;
1074   1      
1075   1          while((!(SPIS_2_RX_STATUS_REG & SPIS_2_STS_RX_FIFO_NOT_EMPTY)) == 0u)
1076   1          {
1077   2              CY_GET_REG8(SPIS_2_RXDATA_PTR);
1078   2          }
1079   1      
1080   1          enableInterrupts = CyEnterCriticalSection();
1081   1      
1082   1          #if(SPIS_2_DataWidth <= 8u)
1083   1      
1084   1              /* Clear TX FIFO */
1085   1              SPIS_2_TX_AUX_CONTROL_DP0_REG |= SPIS_2_FIFO_CLR;
1086   1              SPIS_2_TX_AUX_CONTROL_DP0_REG &= ~SPIS_2_FIFO_CLR;
1087   1      
1088   1          #else
              
                      /* Clear TX FIFO */
                      SPIS_2_TX_AUX_CONTROL_DP0_REG |= SPIS_2_FIFO_CLR;
                      SPIS_2_TX_AUX_CONTROL_DP0_REG &= ~SPIS_2_FIFO_CLR;
                      SPIS_2_TX_AUX_CONTROL_DP1_REG |= SPIS_2_FIFO_CLR;
                      SPIS_2_TX_AUX_CONTROL_DP1_REG &= ~SPIS_2_FIFO_CLR;
              
                  #endif /* SPIS_2_DataWidth > 8u */
1097   1      
1098   1          CyExitCriticalSection(enableInterrupts);
1099   1      }
1100          
1101          
1102          /* Following functions are for version Compatibility, they are obsolete.
1103          *  Please do not use it in new projects.
1104          */
1105          
1106          /*******************************************************************************
1107          * Function Name: SPIS_2_EnableInt
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 19  

1108          ********************************************************************************
1109          *
1110          * Summary:
1111          *  Enable internal interrupt generation.
1112          *
1113          * Parameters:
1114          *  None.
1115          *
1116          * Return:
1117          *  None.
1118          *
1119          * Theory:
1120          *  Enable the internal interrupt output -or- the interrupt component itself.
1121          *
1122          *******************************************************************************/
1123          void SPIS_2_EnableInt(void) 
1124          {
1125   1          #if(SPIS_2_InternalTxInterruptEnabled)    
                      CyIntEnable(SPIS_2_TX_ISR_NUMBER);
                  #endif /* SPIS_2_InternalTxInterruptEnabled */                                
1128   1          
1129   1          #if(SPIS_2_InternalRxInterruptEnabled)           
                      CyIntEnable(SPIS_2_RX_ISR_NUMBER);
                  #endif /* SPIS_2_InternalRxInterruptEnabled */
1132   1      }
1133          
1134          
1135          /*******************************************************************************
1136          * Function Name: SPIS_2_DisableInt
1137          ********************************************************************************
1138          *
1139          * Summary:
1140          *  Disable internal interrupt generation.
1141          *
1142          * Parameters:
1143          *  None.
1144          *
1145          * Return:
1146          *  None.
1147          *
1148          * Theory:
1149          *  Disable the internal interrupt output -or- the interrupt component itself.
1150          *
1151          *******************************************************************************/
1152          void SPIS_2_DisableInt(void) 
1153          {
1154   1          #if(SPIS_2_InternalTxInterruptEnabled)    
                      CyIntDisable(SPIS_2_TX_ISR_NUMBER);
                  #endif /* SPIS_2_InternalTxInterruptEnabled */
1157   1          
1158   1          #if(SPIS_2_InternalRxInterruptEnabled)           
                      CyIntDisable(SPIS_2_RX_ISR_NUMBER);
                  #endif /* SPIS_2_InternalRxInterruptEnabled */
1161   1      }
1162          
1163          
1164          /*******************************************************************************
1165          * Function Name: SPIS_2_SetInterruptMode
1166          ********************************************************************************
1167          *
1168          * Summary:
1169          *  Configure which status bits trigger an interrupt event.
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 20  

1170          *
1171          * Parameters:
1172          *  intSrc: An or'd combination of the desired status bit masks (defined in the
1173          *  header file).
1174          *
1175          * Return:
1176          *  None.
1177          *
1178          * Theory:
1179          *  Enables the output of specific status bits to the interrupt controller.
1180          *
1181          *******************************************************************************/
1182          void SPIS_2_SetInterruptMode(uint8 intSrc) 
1183          {
1184   1          SPIS_2_TX_STATUS_MASK_REG  = intSrc;
1185   1          SPIS_2_RX_STATUS_MASK_REG  = intSrc;
1186   1      }
1187          
1188          
1189          /*******************************************************************************
1190          * Function Name: SPIS_2_ReadStatus
1191          ********************************************************************************
1192          *
1193          * Summary:
1194          *  Read the status register for the component.
1195          *
1196          * Parameters:
1197          *  None.
1198          *
1199          * Return:
1200          *  Contents of the status register.
1201          *
1202          * Global variables:
1203          *  SPIS_2_swStatus - used to store in software status register,
1204          *  modified every function call - resets to zero.
1205          *
1206          * Theory:
1207          *  Allows the user and the API to read the status register for error detection
1208          *  and flow control.
1209          *
1210          * Side Effects:
1211          *  Clear status register of the component.
1212          *
1213          * Reentrant:
1214          *  No.
1215          *
1216          *******************************************************************************/
1217          uint8 SPIS_2_ReadStatus(void)
1218          {
1219   1          uint8 tmpStatus;
1220   1      
1221   1          #if ((SPIS_2_TXBUFFERSIZE > 4u) || (SPIS_2_RXBUFFERSIZE > 4u))
              
                      SPIS_2_DisableInt();
              
                      tmpStatus = SPIS_2_GET_STATUS_TX(SPIS_2_swStatusTx) |
                                  (SPIS_2_GET_STATUS_RX(SPIS_2_swStatusRx) & ~SPIS_2_STS_RX_FIFO_FULL);
              
                      SPIS_2_swStatusTx = 0u;
                      SPIS_2_swStatusRx = 0u;
              
                      /* Enable Interrupts */
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 21  

                      SPIS_2_EnableInt();
              
                  #else /* (SPIS_2_TXBUFFERSIZE < 4u) && (SPIS_2_RXBUFFERSIZE < 4u) */
1235   1      
1236   1              tmpStatus = SPIS_2_TX_STATUS_REG | (SPIS_2_RX_STATUS_REG &
1237   1                                                            ~SPIS_2_STS_RX_FIFO_FULL);
1238   1      
1239   1          #endif /* (SPIS_2_TXBUFFERSIZE > 4u) || (SPIS_2_RXBUFFERSIZE > 4u) */
1240   1      
1241   1          return(tmpStatus);
1242   1      }
1243          
1244          
1245          /* [] END OF FILE */
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 22  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION SPIS_2_Init (BEGIN)
                                           ; SOURCE LINE # 68
                                           ; SOURCE LINE # 69
                                           ; SOURCE LINE # 71
0000 906588            MOV     DPTR,#06588H
0003 7407              MOV     A,#07H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 99
0006 120000      R     LCALL   SPIS_2_ClearFIFO
                                           ; SOURCE LINE # 115
0009 120000      R     LCALL   SPIS_2_ReadTxStatus
                                           ; SOURCE LINE # 116
000C 120000      R     LCALL   SPIS_2_ReadRxStatus
                                           ; SOURCE LINE # 124
000F 90658A            MOV     DPTR,#0658AH
0012 E4                CLR     A
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 127
0014 906589            MOV     DPTR,#06589H
0017 E4                CLR     A
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 129
0019 22                RET     
             ; FUNCTION SPIS_2_Init (END)

             ; FUNCTION SPIS_2_Enable (BEGIN)
                                           ; SOURCE LINE # 146
                                           ; SOURCE LINE # 147
                                           ; SOURCE LINE # 148
0000 900000      R     MOV     DPTR,#enableInterrupts
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 150
0005 120000      E     LCALL   CyEnterCriticalSection
0008 900000      R     MOV     DPTR,#enableInterrupts
000B EF                MOV     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 152
000D 906598            MOV     DPTR,#06598H
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 EF                MOV     A,R7
0013 4420              ORL     A,#020H
0015 FF                MOV     R7,A
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 153
0018 90659A            MOV     DPTR,#0659AH
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 4410              ORL     A,#010H
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 154
0023 906599            MOV     DPTR,#06599H
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 23  

0028 EF                MOV     A,R7
0029 4410              ORL     A,#010H
002B FF                MOV     R7,A
002C EF                MOV     A,R7
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 156
002E 900000      R     MOV     DPTR,#enableInterrupts
0031 E0                MOVX    A,@DPTR
0032 FF                MOV     R7,A
0033 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 165
0036 22                RET     
             ; FUNCTION SPIS_2_Enable (END)

             ; FUNCTION SPIS_2_Start (BEGIN)
                                           ; SOURCE LINE # 192
                                           ; SOURCE LINE # 193
                                           ; SOURCE LINE # 194
0000 900000      R     MOV     DPTR,#SPIS_2_initVar
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 7009              JNZ     ?C0003
                                           ; SOURCE LINE # 195
                                           ; SOURCE LINE # 196
0008 120000      R     LCALL   SPIS_2_Init
                                           ; SOURCE LINE # 197
000B 900000      R     MOV     DPTR,#SPIS_2_initVar
000E 7401              MOV     A,#01H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 198
0011         ?C0003:
                                           ; SOURCE LINE # 200
0011 120000      R     LCALL   SPIS_2_Enable
                                           ; SOURCE LINE # 201
0014 22                RET     
             ; FUNCTION SPIS_2_Start (END)

             ; FUNCTION SPIS_2_Stop (BEGIN)
                                           ; SOURCE LINE # 221
                                           ; SOURCE LINE # 222
                                           ; SOURCE LINE # 223
0000 900000      R     MOV     DPTR,#enableInterrupts
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 225
0005 120000      E     LCALL   CyEnterCriticalSection
0008 900000      R     MOV     DPTR,#enableInterrupts
000B EF                MOV     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 227
000D 90659A            MOV     DPTR,#0659AH
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 EF                MOV     A,R7
0013 54EF              ANL     A,#0EFH
0015 FF                MOV     R7,A
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 228
0018 906599            MOV     DPTR,#06599H
001B E0                MOVX    A,@DPTR
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 24  

001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 54EF              ANL     A,#0EFH
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 230
0023 900000      R     MOV     DPTR,#enableInterrupts
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
0028 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 239
002B 22                RET     
             ; FUNCTION SPIS_2_Stop (END)

             ; FUNCTION SPIS_2_EnableTxInt (BEGIN)
                                           ; SOURCE LINE # 259
                                           ; SOURCE LINE # 260
                                           ; SOURCE LINE # 264
0000 22                RET     
             ; FUNCTION SPIS_2_EnableTxInt (END)

             ; FUNCTION SPIS_2_EnableRxInt (BEGIN)
                                           ; SOURCE LINE # 284
                                           ; SOURCE LINE # 285
                                           ; SOURCE LINE # 289
0000 22                RET     
             ; FUNCTION SPIS_2_EnableRxInt (END)

             ; FUNCTION SPIS_2_DisableTxInt (BEGIN)
                                           ; SOURCE LINE # 309
                                           ; SOURCE LINE # 310
                                           ; SOURCE LINE # 314
0000 22                RET     
             ; FUNCTION SPIS_2_DisableTxInt (END)

             ; FUNCTION SPIS_2_DisableRxInt (BEGIN)
                                           ; SOURCE LINE # 334
                                           ; SOURCE LINE # 335
                                           ; SOURCE LINE # 339
0000 22                RET     
             ; FUNCTION SPIS_2_DisableRxInt (END)

             ; FUNCTION _SPIS_2_SetTxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 360
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 361
                                           ; SOURCE LINE # 362
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 90658A            MOV     DPTR,#0658AH
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 363
000F 22                RET     
             ; FUNCTION _SPIS_2_SetTxInterruptMode (END)

             ; FUNCTION _SPIS_2_SetRxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 384
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 25  

0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 385
                                           ; SOURCE LINE # 386
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906589            MOV     DPTR,#06589H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 387
000F 22                RET     
             ; FUNCTION _SPIS_2_SetRxInterruptMode (END)

             ; FUNCTION SPIS_2_ReadTxStatus (BEGIN)
                                           ; SOURCE LINE # 418
                                           ; SOURCE LINE # 419
                                           ; SOURCE LINE # 420
0000 900000      R     MOV     DPTR,#tmpStatus
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 435
0005 90656A            MOV     DPTR,#0656AH
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 900000      R     MOV     DPTR,#tmpStatus
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 439
000F 900000      R     MOV     DPTR,#tmpStatus
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
                                           ; SOURCE LINE # 440
0014         ?C0012:
0014 22                RET     
             ; FUNCTION SPIS_2_ReadTxStatus (END)

             ; FUNCTION SPIS_2_ReadRxStatus (BEGIN)
                                           ; SOURCE LINE # 471
                                           ; SOURCE LINE # 472
                                           ; SOURCE LINE # 473
0000 900000      R     MOV     DPTR,#tmpStatus
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 488
0005 906569            MOV     DPTR,#06569H
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 900000      R     MOV     DPTR,#tmpStatus
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 492
000F 900000      R     MOV     DPTR,#tmpStatus
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
                                           ; SOURCE LINE # 493
0014         ?C0013:
0014 22                RET     
             ; FUNCTION SPIS_2_ReadRxStatus (END)

             ; FUNCTION _SPIS_2_WriteTxData (BEGIN)
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 26  

                                           ; SOURCE LINE # 530
0000 900000      R     MOV     DPTR,#txData
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 531
0005         ?C0014:
                                           ; SOURCE LINE # 587
0005 90656A            MOV     DPTR,#0656AH
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 5402              ANL     A,#02H
000D FF                MOV     R7,A
000E 7E00              MOV     R6,#00H
0010 EF                MOV     A,R7
0011 4E                ORL     A,R6
0012 60F1              JZ      ?C0014
0014         ?C0015:
                                           ; SOURCE LINE # 590
0014 900000      R     MOV     DPTR,#txData
0017 E0                MOVX    A,@DPTR
0018 FF                MOV     R7,A
0019 90654A            MOV     DPTR,#0654AH
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 593
001E 22                RET     
             ; FUNCTION _SPIS_2_WriteTxData (END)

             ; FUNCTION _SPIS_2_WriteTxDataZero (BEGIN)
                                           ; SOURCE LINE # 616
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 618
                                           ; SOURCE LINE # 619
0005 900000      R     MOV     DPTR,#txDataByte
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 90650A            MOV     DPTR,#0650AH
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 620
000F 22                RET     
             ; FUNCTION _SPIS_2_WriteTxDataZero (END)

             ; FUNCTION SPIS_2_ReadRxData (BEGIN)
                                           ; SOURCE LINE # 658
                                           ; SOURCE LINE # 659
                                           ; SOURCE LINE # 660
0000 900000      R     MOV     DPTR,#rxData
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 690
0005 90655A            MOV     DPTR,#0655AH
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 900000      R     MOV     DPTR,#rxData
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 694
000F 900000      R     MOV     DPTR,#rxData
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 27  

0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
                                           ; SOURCE LINE # 696
0014         ?C0018:
0014 22                RET     
             ; FUNCTION SPIS_2_ReadRxData (END)

             ; FUNCTION SPIS_2_GetRxBufferSize (BEGIN)
                                           ; SOURCE LINE # 724
                                           ; SOURCE LINE # 725
                                           ; SOURCE LINE # 726
0000 900000      R     MOV     DPTR,#size
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 752
0005 906569            MOV     DPTR,#06569H
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 5408              ANL     A,#08H
000D FF                MOV     R7,A
000E 7E00              MOV     R6,#00H
0010 EF                MOV     A,R7
0011 6408              XRL     A,#08H
0013 4E                ORL     A,R6
0014 7004              JNZ     ?C0019
0016 7F01              MOV     R7,#01H
0018 8002              SJMP    ?C0020
001A         ?C0019:
001A 7F00              MOV     R7,#00H
001C         ?C0020:
001C 900000      R     MOV     DPTR,#size
001F EF                MOV     A,R7
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 757
0021 900000      R     MOV     DPTR,#size
0024 E0                MOVX    A,@DPTR
0025 FF                MOV     R7,A
                                           ; SOURCE LINE # 758
0026         ?C0021:
0026 22                RET     
             ; FUNCTION SPIS_2_GetRxBufferSize (END)

             ; FUNCTION SPIS_2_GetTxBufferSize (BEGIN)
                                           ; SOURCE LINE # 790
                                           ; SOURCE LINE # 791
                                           ; SOURCE LINE # 792
0000 900000      R     MOV     DPTR,#size
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 817
0005 90656A            MOV     DPTR,#0656AH
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 900000      R     MOV     DPTR,#size
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 820
000F 900000      R     MOV     DPTR,#size
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 EF                MOV     A,R7
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 28  

0015 5404              ANL     A,#04H
0017 FF                MOV     R7,A
0018 7E00              MOV     R6,#00H
001A EF                MOV     A,R7
001B 6404              XRL     A,#04H
001D 4E                ORL     A,R6
001E 7007              JNZ     ?C0022
                                           ; SOURCE LINE # 821
                                           ; SOURCE LINE # 822
0020 900000      R     MOV     DPTR,#size
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 823
0025 801F              SJMP    ?C0023
0027         ?C0022:
                                           ; SOURCE LINE # 824
0027 900000      R     MOV     DPTR,#size
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C EF                MOV     A,R7
002D 5402              ANL     A,#02H
002F FF                MOV     R7,A
0030 7E00              MOV     R6,#00H
0032 EF                MOV     A,R7
0033 6402              XRL     A,#02H
0035 4E                ORL     A,R6
0036 7008              JNZ     ?C0024
                                           ; SOURCE LINE # 825
                                           ; SOURCE LINE # 826
0038 900000      R     MOV     DPTR,#size
003B 7401              MOV     A,#01H
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 827
003E 8006              SJMP    ?C0023
0040         ?C0024:
                                           ; SOURCE LINE # 829
                                           ; SOURCE LINE # 830
0040 900000      R     MOV     DPTR,#size
0043 7404              MOV     A,#04H
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 831
0046         ?C0023:
                                           ; SOURCE LINE # 835
0046 900000      R     MOV     DPTR,#size
0049 E0                MOVX    A,@DPTR
004A FF                MOV     R7,A
                                           ; SOURCE LINE # 836
004B         ?C0026:
004B 22                RET     
             ; FUNCTION SPIS_2_GetTxBufferSize (END)

             ; FUNCTION SPIS_2_ClearRxBuffer (BEGIN)
                                           ; SOURCE LINE # 872
                                           ; SOURCE LINE # 873
0000         ?C0027:
                                           ; SOURCE LINE # 875
0000 906569            MOV     DPTR,#06569H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 5408              ANL     A,#08H
0008 FF                MOV     R7,A
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 29  

0009 7E00              MOV     R6,#00H
000B EF                MOV     A,R7
000C 4E                ORL     A,R6
000D 7004              JNZ     ?C0029
000F 7F01              MOV     R7,#01H
0011 8002              SJMP    ?C0030
0013         ?C0029:
0013 7F00              MOV     R7,#00H
0015         ?C0030:
0015 EF                MOV     A,R7
0016 7007              JNZ     ?C0031
                                           ; SOURCE LINE # 876
                                           ; SOURCE LINE # 877
0018 90655A            MOV     DPTR,#0655AH
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
                                           ; SOURCE LINE # 878
001D 80E1              SJMP    ?C0027
                                           ; SOURCE LINE # 892
001F         ?C0031:
001F 22                RET     
             ; FUNCTION SPIS_2_ClearRxBuffer (END)

             ; FUNCTION SPIS_2_ClearTxBuffer (BEGIN)
                                           ; SOURCE LINE # 929
                                           ; SOURCE LINE # 930
                                           ; SOURCE LINE # 931
0000 900000      R     MOV     DPTR,#enableInterrupts
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 934
0005 120000      E     LCALL   CyEnterCriticalSection
0008 900000      R     MOV     DPTR,#enableInterrupts
000B EF                MOV     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 939
000D 90659A            MOV     DPTR,#0659AH
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 EF                MOV     A,R7
0013 4403              ORL     A,#03H
0015 FF                MOV     R7,A
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 940
0018 90659A            MOV     DPTR,#0659AH
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 54FC              ANL     A,#0FCH
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 952
0023 900000      R     MOV     DPTR,#enableInterrupts
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
0028 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 969
002B 22                RET     
             ; FUNCTION SPIS_2_ClearTxBuffer (END)

C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 30  

             ; FUNCTION _SPIS_2_PutArray (BEGIN)
                                           ; SOURCE LINE # 1044
0000 900000      R     MOV     DPTR,#buffer
0003 120000      E     LCALL   ?C?PSTXDATA
0006 900000      R     MOV     DPTR,#byteCount
0009 ED                MOV     A,R5
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1045
000B         ?C0033:
                                           ; SOURCE LINE # 1046
000B 900000      R     MOV     DPTR,#byteCount
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 D3                SETB    C
0012 9400              SUBB    A,#00H
0014 4019              JC      ?C0035
                                           ; SOURCE LINE # 1047
                                           ; SOURCE LINE # 1048
0016 900000      R     MOV     DPTR,#buffer
0019 E4                CLR     A
001A 75F001            MOV     B,#01H
001D 120000      E     LCALL   ?C?PLDIXDATA
0020 120000      E     LCALL   ?C?CLDPTR
0023 FF                MOV     R7,A
0024 120000      R     LCALL   _SPIS_2_WriteTxData
                                           ; SOURCE LINE # 1049
0027 900000      R     MOV     DPTR,#byteCount
002A E0                MOVX    A,@DPTR
002B 14                DEC     A
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1050
002D 80DC              SJMP    ?C0033
                                           ; SOURCE LINE # 1051
002F         ?C0035:
002F 22                RET     
             ; FUNCTION _SPIS_2_PutArray (END)

             ; FUNCTION SPIS_2_ClearFIFO (BEGIN)
                                           ; SOURCE LINE # 1071
                                           ; SOURCE LINE # 1072
                                           ; SOURCE LINE # 1073
0000 900000      R     MOV     DPTR,#enableInterrupts
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
0005         ?C0036:
                                           ; SOURCE LINE # 1075
0005 906569            MOV     DPTR,#06569H
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 5408              ANL     A,#08H
000D FF                MOV     R7,A
000E 7E00              MOV     R6,#00H
0010 EF                MOV     A,R7
0011 4E                ORL     A,R6
0012 7004              JNZ     ?C0038
0014 7F01              MOV     R7,#01H
0016 8002              SJMP    ?C0039
0018         ?C0038:
0018 7F00              MOV     R7,#00H
001A         ?C0039:
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 31  

001A EF                MOV     A,R7
001B 7007              JNZ     ?C0037
                                           ; SOURCE LINE # 1076
                                           ; SOURCE LINE # 1077
001D 90655A            MOV     DPTR,#0655AH
0020 E0                MOVX    A,@DPTR
0021 FF                MOV     R7,A
                                           ; SOURCE LINE # 1078
0022 80E1              SJMP    ?C0036
0024         ?C0037:
                                           ; SOURCE LINE # 1080
0024 120000      E     LCALL   CyEnterCriticalSection
0027 900000      R     MOV     DPTR,#enableInterrupts
002A EF                MOV     A,R7
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1085
002C 90659A            MOV     DPTR,#0659AH
002F E0                MOVX    A,@DPTR
0030 FF                MOV     R7,A
0031 EF                MOV     A,R7
0032 4403              ORL     A,#03H
0034 FF                MOV     R7,A
0035 EF                MOV     A,R7
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1086
0037 90659A            MOV     DPTR,#0659AH
003A E0                MOVX    A,@DPTR
003B FF                MOV     R7,A
003C EF                MOV     A,R7
003D 54FC              ANL     A,#0FCH
003F FF                MOV     R7,A
0040 EF                MOV     A,R7
0041 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1098
0042 900000      R     MOV     DPTR,#enableInterrupts
0045 E0                MOVX    A,@DPTR
0046 FF                MOV     R7,A
0047 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1099
004A 22                RET     
             ; FUNCTION SPIS_2_ClearFIFO (END)

             ; FUNCTION SPIS_2_EnableInt (BEGIN)
                                           ; SOURCE LINE # 1123
                                           ; SOURCE LINE # 1124
                                           ; SOURCE LINE # 1132
0000 22                RET     
             ; FUNCTION SPIS_2_EnableInt (END)

             ; FUNCTION SPIS_2_DisableInt (BEGIN)
                                           ; SOURCE LINE # 1152
                                           ; SOURCE LINE # 1153
                                           ; SOURCE LINE # 1161
0000 22                RET     
             ; FUNCTION SPIS_2_DisableInt (END)

             ; FUNCTION _SPIS_2_SetInterruptMode (BEGIN)
                                           ; SOURCE LINE # 1182
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1183
C51 COMPILER V9.03   SPIS_2                                                                02/05/2014 12:33:25 PAGE 32  

                                           ; SOURCE LINE # 1184
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 90658A            MOV     DPTR,#0658AH
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1185
000F 900000      R     MOV     DPTR,#intSrc
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 906589            MOV     DPTR,#06589H
0017 EF                MOV     A,R7
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1186
0019 22                RET     
             ; FUNCTION _SPIS_2_SetInterruptMode (END)

             ; FUNCTION SPIS_2_ReadStatus (BEGIN)
                                           ; SOURCE LINE # 1217
                                           ; SOURCE LINE # 1218
                                           ; SOURCE LINE # 1236
0000 906569            MOV     DPTR,#06569H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 54BF              ANL     A,#0BFH
0008 FF                MOV     R7,A
0009 90656A            MOV     DPTR,#0656AH
000C E0                MOVX    A,@DPTR
000D FE                MOV     R6,A
000E EF                MOV     A,R7
000F 4E                ORL     A,R6
0010 FF                MOV     R7,A
0011 900000      R     MOV     DPTR,#tmpStatus
0014 EF                MOV     A,R7
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1241
0016 900000      R     MOV     DPTR,#tmpStatus
0019 E0                MOVX    A,@DPTR
001A FF                MOV     R7,A
                                           ; SOURCE LINE # 1242
001B         ?C0044:
001B 22                RET     
             ; FUNCTION SPIS_2_ReadStatus (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    662    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
