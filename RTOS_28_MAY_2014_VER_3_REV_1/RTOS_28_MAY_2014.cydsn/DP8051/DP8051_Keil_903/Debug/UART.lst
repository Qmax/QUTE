C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 1   


C51 COMPILER V9.03, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_903\Debug\UART.obj
COMPILER INVOKED BY: C:\Program Files\Cypress\PSoC Creator\2.0\PSoC Creator\import\keil\pk51\9.03\C51\BIN\c51.exe .\Gene
                    -rated_Source\PSoC3\UART.c NOIV LARGE MODDP2 OMF2 VB(1) PR(.\DP8051\DP8051_Keil_903\Debug\UART.lst) CD DB NOIP OT(2,SIZE)
                    - INCDIR(Generated_Source\PSoC3) OJ(.\DP8051\DP8051_Keil_903\Debug\UART.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: UART.c
   3          * Version 2.10
   4          *
   5          * Description:
   6          *  This file provides all API functionality of the UART component
   7          *
   8          * Note:
   9          *
  10          *******************************************************************************
  11          * Copyright 2008-2011, Cypress Semiconductor Corporation.  All rights reserved.
  12          * You may use this file only in accordance with the license, terms, conditions,
  13          * disclaimers, and limitations in the end user license agreement accompanying
  14          * the software package with which this file was provided.
  15          ********************************************************************************/
  16          
  17          
  18          #include "UART.h"
  19          #include "CyLib.h"
  20          
  21          
  22          /***************************************
  23          * Global data allocation
  24          ***************************************/
  25          
  26          #if( UART_TX_ENABLED && (UART_TXBUFFERSIZE > UART_FIFO_LENGTH))
  27              volatile uint8 UART_txBuffer[UART_TXBUFFERSIZE];
  28              volatile uint8 UART_txBufferRead = 0u;
  29              uint8 UART_txBufferWrite = 0u;
  30          #endif /* End UART_TX_ENABLED */
  31          #if( ( UART_RX_ENABLED || UART_HD_ENABLED ) && \
  32               (UART_RXBUFFERSIZE > UART_FIFO_LENGTH) )
  33              volatile uint8 UART_rxBuffer[UART_RXBUFFERSIZE];
  34              volatile uint8 UART_rxBufferRead = 0u;
  35              volatile uint8 UART_rxBufferWrite = 0u;
  36              volatile uint8 UART_rxBufferLoopDetect = 0u;
  37              volatile uint8 UART_rxBufferOverflow = 0u;
  38              #if (UART_RXHW_ADDRESS_ENABLED)
                      volatile uint8 UART_rxAddressMode = UART_RXADDRESSMODE;
                      volatile uint8 UART_rxAddressDetected = 0u;
                  #endif /* End EnableHWAddress */    
  42          #endif /* End UART_RX_ENABLED */
  43          
  44          
  45          /***************************************
  46          * Local data allocation
  47          ***************************************/
  48          
  49          uint8 UART_initVar = 0u;
  50          
  51          
  52          /*******************************************************************************
  53          * Function Name: UART_Start
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 2   

  54          ********************************************************************************
  55          *
  56          * Summary:
  57          *  Initialize and Enable the UART component.
  58          *  Enable the clock input to enable operation.
  59          *
  60          * Parameters:
  61          *  None.
  62          *
  63          * Return:
  64          *  None.
  65          *
  66          * Global variables:
  67          *  The UART_intiVar variable is used to indicate initial 
  68          *  configuration of this component. The variable is initialized to zero (0u) 
  69          *  and set to one (1u) the first time UART_Start() is called. This allows for 
  70          *  component initialization without re-initialization in all subsequent calls 
  71          *  to the UART_Start() routine. 
  72          *
  73          * Reentrant:
  74          *  No.
  75          *
  76          *******************************************************************************/
  77          void UART_Start(void) 
  78          {
  79   1          /* If not Initialized then initialize all required hardware and software */
  80   1          if(UART_initVar == 0u)
  81   1          {
  82   2              UART_Init();
  83   2              UART_initVar = 1u;
  84   2          }
  85   1          UART_Enable();
  86   1      }
  87          
  88          
  89          /*******************************************************************************
  90          * Function Name: UART_Init
  91          ********************************************************************************
  92          *
  93          * Summary:
  94          *  Initialize component's parameters to the parameters set by user in the
  95          *  customizer of the component placed onto schematic. Usually called in
  96          *  UART_Start().
  97          *
  98          * Parameters:
  99          *  None.
 100          *
 101          * Return:
 102          *  None.
 103          *
 104          *******************************************************************************/
 105          void UART_Init(void) 
 106          {
 107   1          #if(UART_RX_ENABLED || UART_HD_ENABLED)
 108   1      
 109   1              #if(UART_RX_INTERRUPT_ENABLED && (UART_RXBUFFERSIZE > UART_FIFO_LENGTH))
 110   1                  /* Set the RX Interrupt. */
 111   1                  CyIntSetVector(UART_RX_VECT_NUM,   UART_RXISR);
 112   1                  CyIntSetPriority(UART_RX_VECT_NUM, UART_RX_PRIOR_NUM);
 113   1              #endif /* End UART_RX_INTERRUPT_ENABLED */
 114   1      
 115   1              #if (UART_RXHW_ADDRESS_ENABLED)
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 3   

                          UART_SetRxAddressMode(UART_RXAddressMode);
                          UART_SetRxAddress1(UART_RXHWADDRESS1);
                          UART_SetRxAddress2(UART_RXHWADDRESS2);
                      #endif /* End UART_RXHW_ADDRESS_ENABLED */
 120   1      
 121   1              /* Configure the Initial RX interrupt mask */
 122   1              UART_RXSTATUS_MASK_REG  = UART_INIT_RX_INTERRUPTS_MASK;
 123   1          #endif /* End UART_RX_ENABLED || UART_HD_ENABLED*/
 124   1      
 125   1          #if(UART_TX_ENABLED)
 126   1              #if(UART_TX_INTERRUPT_ENABLED && (UART_TXBUFFERSIZE > UART_FIFO_LENGTH))
 127   1                  /* Set the TX Interrupt. */
 128   1                  CyIntSetVector(UART_TX_VECT_NUM,   UART_TXISR);
 129   1                  CyIntSetPriority(UART_TX_VECT_NUM, UART_TX_PRIOR_NUM);
 130   1              #endif /* End UART_TX_INTERRUPT_ENABLED */
 131   1      
 132   1              /* Write Counter Value for TX Bit Clk Generator*/
 133   1              #if(UART_TXCLKGEN_DP)
 134   1                  UART_TXBITCLKGEN_CTR_REG = UART_BIT_CENTER;
 135   1                  UART_TXBITCLKTX_COMPLETE_REG = (UART_NUMBER_OF_DATA_BITS + \
 136   1                                                          UART_NUMBER_OF_START_BIT) * \
 137   1                                                          UART_OVER_SAMPLE_COUNT;
 138   1              #else
                          UART_TXBITCTR_COUNTER_REG = (UART_NUMBER_OF_DATA_BITS + \
                                                                  UART_NUMBER_OF_START_BIT) * \
                                                                  UART_OVER_SAMPLE_8;
                      #endif /* End UART_TXCLKGEN_DP */
 143   1      
 144   1              /* Configure the Initial TX interrupt mask */
 145   1              #if(UART_TX_INTERRUPT_ENABLED && (UART_TXBUFFERSIZE > UART_FIFO_LENGTH))
 146   1                  UART_TXSTATUS_MASK_REG = UART_TX_STS_FIFO_EMPTY;
 147   1              #else
                          UART_TXSTATUS_MASK_REG = UART_INIT_TX_INTERRUPTS_MASK;
                      #endif /*End UART_TX_INTERRUPT_ENABLED*/
 150   1              
 151   1          #endif /* End UART_TX_ENABLED */
 152   1      
 153   1          #if(UART_PARITY_TYPE_SW)  /* Write Parity to Control Register */
                      UART_WriteControlRegister( \
                          (UART_ReadControlRegister() & ~UART_CTRL_PARITY_TYPE_MASK) | \
                          (UART_PARITY_TYPE << UART_CTRL_PARITY_TYPE0_SHIFT) );
                  #endif /* End UART_PARITY_TYPE_SW */
 158   1      }
 159          
 160          
 161          /*******************************************************************************
 162          * Function Name: UART_Enable
 163          ********************************************************************************
 164          *
 165          * Summary:
 166          *  Enables the UART block operation
 167          *
 168          * Parameters:
 169          *  None.
 170          *
 171          * Return:
 172          *  None.
 173          *
 174          * Global Variables:
 175          *  UART_rxAddressDetected - set to initial state (0).
 176          *
 177          *******************************************************************************/
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 4   

 178          void UART_Enable(void) 
 179          {
 180   1          uint8 enableInterrupts;
 181   1          enableInterrupts = CyEnterCriticalSection();
 182   1          
 183   1          #if(UART_RX_ENABLED || UART_HD_ENABLED)
 184   1              /*RX Counter (Count7) Enable */
 185   1              UART_RXBITCTR_CONTROL_REG |= UART_CNTR_ENABLE;
 186   1              /* Enable the RX Interrupt. */
 187   1              UART_RXSTATUS_ACTL_REG  |= UART_INT_ENABLE;
 188   1              #if(UART_RX_INTERRUPT_ENABLED && (UART_RXBUFFERSIZE > UART_FIFO_LENGTH))
 189   1                  CyIntEnable(UART_RX_VECT_NUM);
 190   1                  #if (UART_RXHW_ADDRESS_ENABLED)
                              UART_rxAddressDetected = 0u;
                          #endif /* End UART_RXHW_ADDRESS_ENABLED */
 193   1              #endif /* End UART_RX_INTERRUPT_ENABLED */
 194   1          #endif /* End UART_RX_ENABLED || UART_HD_ENABLED*/
 195   1      
 196   1          #if(UART_TX_ENABLED)
 197   1              /*TX Counter (DP/Count7) Enable */
 198   1              #if(!UART_TXCLKGEN_DP)
                          UART_TXBITCTR_CONTROL_REG |= UART_CNTR_ENABLE;
                      #endif /* End UART_TXCLKGEN_DP */
 201   1              /* Enable the TX Interrupt. */
 202   1              UART_TXSTATUS_ACTL_REG |= UART_INT_ENABLE;
 203   1              #if(UART_TX_INTERRUPT_ENABLED && (UART_TXBUFFERSIZE > UART_FIFO_LENGTH))
 204   1                  CyIntEnable(UART_TX_VECT_NUM);
 205   1              #endif /* End UART_TX_INTERRUPT_ENABLED*/
 206   1           #endif /* End UART_TX_ENABLED */
 207   1      
 208   1          #if(UART_INTERNAL_CLOCK_USED)
                      /* Set the bit to enable the clock. */
                      UART_INTCLOCK_CLKEN_REG |= UART_INTCLOCK_CLKEN_MASK;
                  #endif /* End UART_INTERNAL_CLOCK_USED */
 212   1          
 213   1          CyExitCriticalSection(enableInterrupts);
 214   1      }
 215          
 216          
 217          /*******************************************************************************
 218          * Function Name: UART_Stop
 219          ********************************************************************************
 220          *
 221          * Summary:
 222          *  Disable the UART component
 223          *
 224          * Parameters:
 225          *  None.
 226          *
 227          * Return:
 228          *  None.
 229          *
 230          *******************************************************************************/
 231          void UART_Stop(void) 
 232          {
 233   1          uint8 enableInterrupts;
 234   1          enableInterrupts = CyEnterCriticalSection();
 235   1      
 236   1          /*Write Bit Counter Disable */
 237   1          #if(UART_RX_ENABLED || UART_HD_ENABLED)
 238   1              UART_RXBITCTR_CONTROL_REG &= ~UART_CNTR_ENABLE;
 239   1          #endif /* End UART_RX_ENABLED */
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 5   

 240   1      
 241   1          #if(UART_TX_ENABLED)
 242   1              #if(!UART_TXCLKGEN_DP)
                          UART_TXBITCTR_CONTROL_REG &= ~UART_CNTR_ENABLE;
                      #endif /* End UART_TXCLKGEN_DP */
 245   1          #endif /* UART_TX_ENABLED */
 246   1      
 247   1          #if(UART_INTERNAL_CLOCK_USED)
                      /* Clear the bit to enable the clock. */
                      UART_INTCLOCK_CLKEN_REG &= ~UART_INTCLOCK_CLKEN_MASK;
                  #endif /* End UART_INTERNAL_CLOCK_USED */
 251   1          
 252   1          /*Disable internal interrupt component*/
 253   1          #if(UART_RX_ENABLED || UART_HD_ENABLED)
 254   1              UART_RXSTATUS_ACTL_REG  &= ~UART_INT_ENABLE;
 255   1              #if(UART_RX_INTERRUPT_ENABLED && (UART_RXBUFFERSIZE > UART_FIFO_LENGTH))
 256   1                  UART_DisableRxInt();
 257   1              #endif /* End UART_RX_INTERRUPT_ENABLED */
 258   1          #endif /* End UART_RX_ENABLED */
 259   1          
 260   1          #if(UART_TX_ENABLED)
 261   1              UART_TXSTATUS_ACTL_REG &= ~UART_INT_ENABLE;
 262   1              #if(UART_TX_INTERRUPT_ENABLED && (UART_TXBUFFERSIZE > UART_FIFO_LENGTH))
 263   1                  UART_DisableTxInt();
 264   1              #endif /* End UART_TX_INTERRUPT_ENABLED */
 265   1          #endif /* End UART_TX_ENABLED */
 266   1      
 267   1          CyExitCriticalSection(enableInterrupts);
 268   1      }
 269          
 270          
 271          /*******************************************************************************
 272          * Function Name: UART_ReadControlRegister
 273          ********************************************************************************
 274          *
 275          * Summary:
 276          *  Read the current state of the control register
 277          *
 278          * Parameters:
 279          *  None.
 280          *
 281          * Return:
 282          *  Current state of the control register.
 283          *
 284          *******************************************************************************/
 285          uint8 UART_ReadControlRegister(void) 
 286          {
 287   1          #if( UART_CONTROL_REG_REMOVED )
 288   1              return(0u);
 289   1          #else
                      return(UART_CONTROL_REG);
                  #endif /* End UART_CONTROL_REG_REMOVED */
 292   1      }
 293          
 294          
 295          /*******************************************************************************
 296          * Function Name: UART_WriteControlRegister
 297          ********************************************************************************
 298          *
 299          * Summary:
 300          *  Writes an 8-bit value into the control register
 301          *
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 6   

 302          * Parameters:
 303          *  control:  control register value
 304          *
 305          * Return:
 306          *  None.
 307          *
 308          *******************************************************************************/
 309          void  UART_WriteControlRegister(uint8 control) 
 310          {
 311   1          #if( UART_CONTROL_REG_REMOVED )
 312   1              control = control;      /* Reassigning to release compiler warning */ 
 313   1          #else
                     UART_CONTROL_REG = control;
                  #endif /* End UART_CONTROL_REG_REMOVED */
 316   1      }
 317          
 318          
 319          #if(UART_RX_ENABLED || UART_HD_ENABLED)
 320          
 321              #if(UART_RX_INTERRUPT_ENABLED)
 322          
 323                  /*******************************************************************************
 324                  * Function Name: UART_EnableRxInt
 325                  ********************************************************************************
 326                  *
 327                  * Summary:
 328                  *  Enable RX interrupt generation
 329                  *
 330                  * Parameters:
 331                  *  None.
 332                  *
 333                  * Return:
 334                  *  None.
 335                  *
 336                  * Theory:
 337                  *  Enable the interrupt output -or- the interrupt component itself
 338                  *
 339                  *******************************************************************************/
 340                  void UART_EnableRxInt(void) 
 341                  {
 342   1                  CyIntEnable(UART_RX_VECT_NUM);
 343   1              }
 344          
 345          
 346                  /*******************************************************************************
 347                  * Function Name: UART_DisableRxInt
 348                  ********************************************************************************
 349                  *
 350                  * Summary:
 351                  *  Disable RX interrupt generation
 352                  *
 353                  * Parameters:
 354                  *  None.
 355                  *
 356                  * Return:
 357                  *  None.
 358                  *
 359                  * Theory:
 360                  *  Disable the interrupt output -or- the interrupt component itself
 361                  *
 362                  *******************************************************************************/
 363                  void UART_DisableRxInt(void) 
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 7   

 364                  {
 365   1                  CyIntDisable(UART_RX_VECT_NUM);
 366   1              }
 367          
 368              #endif /* UART_RX_INTERRUPT_ENABLED */
 369          
 370          
 371              /*******************************************************************************
 372              * Function Name: UART_SetRxInterruptMode
 373              ********************************************************************************
 374              *
 375              * Summary:
 376              *  Configure which status bits trigger an interrupt event
 377              *
 378              * Parameters:
 379              *  IntSrc:  An or'd combination of the desired status bit masks (defined in
 380              *           the header file)
 381              *
 382              * Return:
 383              *  None.
 384              *
 385              * Theory:
 386              *  Enables the output of specific status bits to the interrupt controller
 387              *
 388              *******************************************************************************/
 389              void UART_SetRxInterruptMode(uint8 intSrc) 
 390              {
 391   1              UART_RXSTATUS_MASK_REG  = intSrc;
 392   1          }
 393          
 394          
 395              /*******************************************************************************
 396              * Function Name: UART_ReadRxData
 397              ********************************************************************************
 398              *
 399              * Summary:
 400              *  Returns data in RX Data register without checking status register to 
 401              *  determine if data is valid
 402              *
 403              * Parameters:
 404              *  None.
 405              *
 406              * Return:
 407              *  Received data from RX register
 408              *
 409              * Global Variables:
 410              *  UART_rxBuffer - RAM buffer pointer for save received data.
 411              *  UART_rxBufferWrite - cyclic index for write to rxBuffer, 
 412              *     checked to identify new data. 
 413              *  UART_rxBufferRead - cyclic index for read from rxBuffer, 
 414              *     incremented after each byte has been read from buffer.
 415              *  UART_rxBufferLoopDetect - creared if loop condition was detected
 416              *     in RX ISR. 
 417              *
 418              * Reentrant:
 419              *  No.
 420              *
 421              *******************************************************************************/
 422              uint8 UART_ReadRxData(void) 
 423              {
 424   1              uint8 rxData;
 425   1      
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 8   

 426   1              #if(UART_RXBUFFERSIZE > UART_FIFO_LENGTH)
 427   1      
 428   1                  /* Disable Rx interrupt. */
 429   1                  /* Protect variables that could change on interrupt. */
 430   1                  #if(UART_RX_INTERRUPT_ENABLED)
 431   1                      UART_DisableRxInt();
 432   1                  #endif /* End UART_RX_INTERRUPT_ENABLED */
 433   1      
 434   1                  if( (UART_rxBufferRead != UART_rxBufferWrite) ||
 435   1                      (UART_rxBufferLoopDetect > 0u) )
 436   1                  {
 437   2      
 438   2                      rxData = UART_rxBuffer[UART_rxBufferRead];
 439   2      
 440   2                      UART_rxBufferRead++;
 441   2      
 442   2                      if(UART_rxBufferRead >= UART_RXBUFFERSIZE)
 443   2                      {
 444   3                          UART_rxBufferRead = 0u;
 445   3                      }
 446   2      
 447   2                      if(UART_rxBufferLoopDetect > 0u )
 448   2                      {
 449   3                          UART_rxBufferLoopDetect = 0u;
 450   3                          #if( (UART_RX_INTERRUPT_ENABLED) && (UART_FLOW_CONTROL != 0u) && \
 451   3                               (UART_RXBUFFERSIZE > UART_FIFO_LENGTH) )
                                      /* When Hardware Flow Control selected - return RX mask */
                                      #if( UART_HD_ENABLED )
                                          if((UART_CONTROL_REG & UART_CTRL_HD_SEND) == 0)
                                          {   /* In Half duplex mode return RX mask only in RX configuration set, otherw
             -ise 
                                              *  mask will be returned in LoadRxConfig() API. 
                                              */
                                              UART_RXSTATUS_MASK_REG  |= UART_RX_STS_FIFO_NOTEMPTY;
                                          }
                                      #else
                                          UART_RXSTATUS_MASK_REG  |= UART_RX_STS_FIFO_NOTEMPTY;
                                      #endif /* end UART_HD_ENABLED */
                                  #endif /* UART_RX_INTERRUPT_ENABLED and Hardware flow control*/
 464   3                      }
 465   2                  }
 466   1                  else
 467   1                  {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
 468   2                      rxData = UART_RXDATA_REG;
 469   2                  }
 470   1      
 471   1                  /* Enable Rx interrupt. */
 472   1                  #if(UART_RX_INTERRUPT_ENABLED)
 473   1                      UART_EnableRxInt();
 474   1                  #endif /* End UART_RX_INTERRUPT_ENABLED */
 475   1      
 476   1              #else /* UART_RXBUFFERSIZE > UART_FIFO_LENGTH */
              
                          /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
                          rxData = UART_RXDATA_REG;
              
                      #endif /* UART_RXBUFFERSIZE > UART_FIFO_LENGTH */
 482   1      
 483   1              return(rxData);
 484   1          }
 485          
 486          
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 9   

 487              /*******************************************************************************
 488              * Function Name: UART_ReadRxStatus
 489              ********************************************************************************
 490              *
 491              * Summary:
 492              *  Read the current state of the status register
 493              *  And detect software buffer overflow.
 494              *
 495              * Parameters:
 496              *  None.
 497              *
 498              * Return:
 499              *  Current state of the status register.
 500              *
 501              * Global Variables:
 502              *  UART_rxBufferOverflow - used to indicate overload condition. 
 503              *   It set to one in RX interrupt when there isn?t free space in 
 504              *   UART_rxBufferRead to write new data. This condition returned 
 505              *   and cleared to zero by this API as an 
 506              *   UART_RX_STS_SOFT_BUFF_OVER bit along with RX Status register 
 507              *   bits.
 508              *
 509              *******************************************************************************/
 510              uint8 UART_ReadRxStatus(void) 
 511              {
 512   1              uint8 status;
 513   1      
 514   1              status = UART_RXSTATUS_REG;
 515   1              status &= UART_RX_HW_MASK;
 516   1      
 517   1              #if(UART_RXBUFFERSIZE > UART_FIFO_LENGTH)
 518   1                  if( UART_rxBufferOverflow )
 519   1                  {
 520   2                      status |= UART_RX_STS_SOFT_BUFF_OVER;
 521   2                      UART_rxBufferOverflow = 0u;
 522   2                  }
 523   1              #endif /* UART_RXBUFFERSIZE */
 524   1      
 525   1              return(status);
 526   1          }
 527          
 528          
 529              /*******************************************************************************
 530              * Function Name: UART_GetChar
 531              ********************************************************************************
 532              *
 533              * Summary:
 534              *  Reads UART RX buffer immediately, if data is not available or an error 
 535              *  condition exists, zero is returned; otherwise, character is read and 
 536              *  returned.
 537              *
 538              * Parameters:
 539              *  None.
 540              *
 541              * Return:
 542              *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 543              *  A returned zero signifies an error condition or no data available.
 544              *
 545              * Global Variables:
 546              *  UART_rxBuffer - RAM buffer pointer for save received data.
 547              *  UART_rxBufferWrite - cyclic index for write to rxBuffer, 
 548              *     checked to identify new data. 
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 10  

 549              *  UART_rxBufferRead - cyclic index for read from rxBuffer, 
 550              *     incremented after each byte has been read from buffer.
 551              *  UART_rxBufferLoopDetect - creared if loop condition was detected
 552              *     in RX ISR. 
 553              *
 554              * Reentrant:
 555              *  No.
 556              *
 557              *******************************************************************************/
 558              uint8 UART_GetChar(void) 
 559              {
 560   1              uint8 rxData = 0u;
 561   1              uint8 rxStatus;
 562   1      
 563   1              #if(UART_RXBUFFERSIZE > UART_FIFO_LENGTH)
 564   1      
 565   1                  /* Disable Rx interrupt. */
 566   1                  /* Protect variables that could change on interrupt. */
 567   1                  #if(UART_RX_INTERRUPT_ENABLED)
 568   1                      UART_DisableRxInt();
 569   1                  #endif /* UART_RX_INTERRUPT_ENABLED */
 570   1      
 571   1                  if( (UART_rxBufferRead != UART_rxBufferWrite) ||
 572   1                      (UART_rxBufferLoopDetect > 0u) )
 573   1                  {
 574   2                      rxData = UART_rxBuffer[UART_rxBufferRead];
 575   2      
 576   2                      UART_rxBufferRead++;
 577   2      
 578   2                      if(UART_rxBufferRead >= UART_RXBUFFERSIZE)
 579   2                      {
 580   3                          UART_rxBufferRead = 0u;
 581   3                      }
 582   2      
 583   2                      if(UART_rxBufferLoopDetect > 0u ) 
 584   2                      {
 585   3                          UART_rxBufferLoopDetect = 0u;
 586   3                          #if( (UART_RX_INTERRUPT_ENABLED) && (UART_FLOW_CONTROL != 0u) && \
 587   3                               (UART_RXBUFFERSIZE > UART_FIFO_LENGTH) )
                                      /* When Hardware Flow Control selected - return RX mask */
                                      #if( UART_HD_ENABLED )
                                          if((UART_CONTROL_REG & UART_CTRL_HD_SEND) == 0)
                                          {   /* In Half duplex mode return RX mask only in RX configuration set, otherw
             -ise 
                                              *  mask will be returned in LoadRxConfig() API. 
                                              */
                                              UART_RXSTATUS_MASK_REG  |= UART_RX_STS_FIFO_NOTEMPTY;
                                          }
                                      #else
                                          UART_RXSTATUS_MASK_REG  |= UART_RX_STS_FIFO_NOTEMPTY;
                                      #endif /* end UART_HD_ENABLED */
                                  #endif /* UART_RX_INTERRUPT_ENABLED and Hardware flow control*/
 600   3                      }
 601   2      
 602   2                  }
 603   1                  else
 604   1                  {   rxStatus =UART_RXSTATUS_REG;
 605   2                      if(rxStatus & UART_RX_STS_FIFO_NOTEMPTY)
 606   2                      {   /* Read received data from FIFO*/
 607   3                          rxData = UART_RXDATA_REG;
 608   3                          /*Check status on error*/
 609   3                          if(rxStatus & (UART_RX_STS_BREAK | UART_RX_STS_PAR_ERROR |
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 11  

 610   3                                         UART_RX_STS_STOP_ERROR | UART_RX_STS_OVERRUN))
 611   3                          {
 612   4                              rxData = 0u;
 613   4                          }    
 614   3                      }
 615   2                  }
 616   1      
 617   1                  /* Enable Rx interrupt. */
 618   1                  #if(UART_RX_INTERRUPT_ENABLED)
 619   1                      UART_EnableRxInt();
 620   1                  #endif /* UART_RX_INTERRUPT_ENABLED */
 621   1      
 622   1              #else /* UART_RXBUFFERSIZE > UART_FIFO_LENGTH */
              
                          rxStatus =UART_RXSTATUS_REG;
                          if(rxStatus & UART_RX_STS_FIFO_NOTEMPTY)
                          {   /* Read received data from FIFO*/
                              rxData = UART_RXDATA_REG;
                              /*Check status on error*/
                              if(rxStatus & (UART_RX_STS_BREAK | UART_RX_STS_PAR_ERROR |
                                             UART_RX_STS_STOP_ERROR | UART_RX_STS_OVERRUN))
                              {
                                  rxData = 0u;
                              }
                          }
                      #endif /* UART_RXBUFFERSIZE > UART_FIFO_LENGTH */
 636   1      
 637   1              return(rxData);
 638   1          }
 639          
 640          
 641              /*******************************************************************************
 642              * Function Name: UART_GetByte
 643              ********************************************************************************
 644              *
 645              * Summary:
 646              *  Grab the next available byte of data from the recieve FIFO
 647              *
 648              * Parameters:
 649              *  None.
 650              *
 651              * Return:
 652              *  MSB contains Status Register and LSB contains UART RX data
 653              *
 654              * Reentrant:
 655              *  No.
 656              *
 657              *******************************************************************************/
 658              uint16 UART_GetByte(void) 
 659              {
 660   1              return ( ((uint16)UART_ReadRxStatus() << 8u) | UART_ReadRxData() );
 661   1          }
 662          
 663          
 664              /*******************************************************************************
 665              * Function Name: UART_GetRxBufferSize
 666              ********************************************************************************
 667              *
 668              * Summary:
 669              *  Determine the amount of bytes left in the RX buffer and return the count in
 670              *  bytes
 671              *
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 12  

 672              * Parameters:
 673              *  None.
 674              *
 675              * Return:
 676              *  uint8: Integer count of the number of bytes left 
 677              *  in the RX buffer
 678              *
 679              * Global Variables:
 680              *  UART_rxBufferWrite - used to calculate left bytes. 
 681              *  UART_rxBufferRead - used to calculate left bytes.
 682              *  UART_rxBufferLoopDetect - checked to decide left bytes amount. 
 683              *
 684              * Reentrant:
 685              *  No.
 686              *
 687              * Theory:
 688              *  Allows the user to find out how full the RX Buffer is.
 689              *
 690              *******************************************************************************/
 691              uint8 UART_GetRxBufferSize(void) 
 692                                                                      
 693              {
 694   1              uint8 size;
 695   1      
 696   1              #if(UART_RXBUFFERSIZE > UART_FIFO_LENGTH)
 697   1      
 698   1                  /* Disable Rx interrupt. */
 699   1                  /* Protect variables that could change on interrupt. */
 700   1                  #if(UART_RX_INTERRUPT_ENABLED)
 701   1                      UART_DisableRxInt();
 702   1                  #endif /* UART_RX_INTERRUPT_ENABLED */
 703   1      
 704   1                  if(UART_rxBufferRead == UART_rxBufferWrite)
 705   1                  {
 706   2                      if(UART_rxBufferLoopDetect > 0u)
 707   2                      {
 708   3                          size = UART_RXBUFFERSIZE;
 709   3                      }
 710   2                      else
 711   2                      {
 712   3                          size = 0u;
 713   3                      }
 714   2                  }
 715   1                  else if(UART_rxBufferRead < UART_rxBufferWrite)
 716   1                  {
 717   2                      size = (UART_rxBufferWrite - UART_rxBufferRead);
 718   2                  }
 719   1                  else
 720   1                  {
 721   2                      size = (UART_RXBUFFERSIZE - UART_rxBufferRead) + UART_rxBufferWrite;
 722   2                  }
 723   1      
 724   1                  /* Enable Rx interrupt. */
 725   1                  #if(UART_RX_INTERRUPT_ENABLED)
 726   1                      UART_EnableRxInt();
 727   1                  #endif /* End UART_RX_INTERRUPT_ENABLED */
 728   1      
 729   1              #else /* UART_RXBUFFERSIZE > UART_FIFO_LENGTH */
              
                          /* We can only know if there is data in the fifo. */
                          size = (UART_RXSTATUS_REG & UART_RX_STS_FIFO_NOTEMPTY) ? 1u : 0u;
              
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 13  

                      #endif /* End UART_RXBUFFERSIZE > UART_FIFO_LENGTH */
 735   1      
 736   1              return(size);
 737   1          }
 738          
 739          
 740              /*******************************************************************************
 741              * Function Name: UART_ClearRxBuffer
 742              ********************************************************************************
 743              *
 744              * Summary:
 745              *  Clears the RX RAM buffer by setting the read and write pointers both to zero.
 746              *  Clears hardware RX FIFO.
 747              *
 748              * Parameters:
 749              *  None.
 750              *
 751              * Return:
 752              *  None.
 753              *
 754              * Global Variables:
 755              *  UART_rxBufferWrite - cleared to zero. 
 756              *  UART_rxBufferRead - cleared to zero.
 757              *  UART_rxBufferLoopDetect - cleared to zero. 
 758              *  UART_rxBufferOverflow - cleared to zero. 
 759              *
 760              * Reentrant:
 761              *  No.
 762              *
 763              * Theory:
 764              *  Setting the pointers to zero makes the system believe there is no data to 
 765              *  read and writing will resume at address 0 overwriting any data that may 
 766              *  have remained in the RAM.
 767              *
 768              * Side Effects:
 769              *  Any received data not read from the RAM or FIFO buffer will be lost.
 770              *******************************************************************************/
 771              void UART_ClearRxBuffer(void) 
 772              {
 773   1              uint8 enableInterrupts;
 774   1              
 775   1              /* clear the HW FIFO */
 776   1              /* Enter critical section */
 777   1              enableInterrupts = CyEnterCriticalSection();        
 778   1              UART_RXDATA_AUX_CTL_REG |=  UART_RX_FIFO_CLR;
 779   1              UART_RXDATA_AUX_CTL_REG &= ~UART_RX_FIFO_CLR;
 780   1              /* Exit critical section */
 781   1              CyExitCriticalSection(enableInterrupts);
 782   1              
 783   1              #if(UART_RXBUFFERSIZE > UART_FIFO_LENGTH)
 784   1                  /* Disable Rx interrupt. */
 785   1                  /* Protect variables that could change on interrupt. */
 786   1                  #if(UART_RX_INTERRUPT_ENABLED)
 787   1                      UART_DisableRxInt();
 788   1                  #endif /* End UART_RX_INTERRUPT_ENABLED */
 789   1      
 790   1                  UART_rxBufferRead = 0u;
 791   1                  UART_rxBufferWrite = 0u;
 792   1                  UART_rxBufferLoopDetect = 0u;
 793   1                  UART_rxBufferOverflow = 0u;
 794   1      
 795   1                  /* Enable Rx interrupt. */
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 14  

 796   1                  #if(UART_RX_INTERRUPT_ENABLED)
 797   1                      UART_EnableRxInt();
 798   1                  #endif /* End UART_RX_INTERRUPT_ENABLED */
 799   1              #endif /* End UART_RXBUFFERSIZE > UART_FIFO_LENGTH */
 800   1              
 801   1          }
 802          
 803          
 804              /*******************************************************************************
 805              * Function Name: UART_SetRxAddressMode
 806              ********************************************************************************
 807              *
 808              * Summary:
 809              *  Set the receive addressing mode
 810              *
 811              * Parameters:
 812              *  addressMode: Enumerated value indicating the mode of RX addressing
 813              *  UART__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address 
 814              *                                               detection
 815              *  UART__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer 
 816              *                                               address detection
 817              *  UART__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address 
 818              *                                               detection
 819              *  UART__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer 
 820              *                                               address detection
 821              *  UART__B_UART__AM_NONE - No address detection
 822              *
 823              * Return:
 824              *  None.
 825              *
 826              * Global Variables:
 827              *  UART_rxAddressMode - the parameter stored in this variable for 
 828              *   the farther usage in RX ISR.
 829              *  UART_rxAddressDetected - set to initial state (0).
 830              *
 831              *******************************************************************************/
 832              void UART_SetRxAddressMode(uint8 addressMode)  
 833                                                                  
 834              {
 835   1              #if(UART_RXHW_ADDRESS_ENABLED)
                          #if(UART_CONTROL_REG_REMOVED)
                              addressMode = addressMode;
                          #else /* UART_CONTROL_REG_REMOVED */
                              uint8 tmpCtrl = 0u;
                              tmpCtrl = UART_CONTROL_REG & ~UART_CTRL_RXADDR_MODE_MASK;
                              tmpCtrl |= ((addressMode << UART_CTRL_RXADDR_MODE0_SHIFT) & 
                                         UART_CTRL_RXADDR_MODE_MASK);
                              UART_CONTROL_REG = tmpCtrl;
                              #if(UART_RX_INTERRUPT_ENABLED && \
                                 (UART_RXBUFFERSIZE > UART_FIFO_LENGTH) )
                                  UART_rxAddressMode = addressMode;
                                  UART_rxAddressDetected = 0u;
                              #endif /* End UART_RXBUFFERSIZE > UART_FIFO_LENGTH*/   
                          #endif /* End UART_CONTROL_REG_REMOVED */
                      #else /* UART_RXHW_ADDRESS_ENABLED */
 851   1                  addressMode = addressMode;
 852   1              #endif /* End UART_RXHW_ADDRESS_ENABLED */
 853   1          }
 854          
 855          
 856              /*******************************************************************************
 857              * Function Name: UART_SetRxAddress1
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 15  

 858              ********************************************************************************
 859              *
 860              * Summary:
 861              *  Set the first hardware address compare value
 862              *
 863              * Parameters:
 864              *  address
 865              *
 866              * Return:
 867              *  None.
 868              *
 869              *******************************************************************************/
 870              void UART_SetRxAddress1(uint8 address) 
 871          
 872              {
 873   1              UART_RXADDRESS1_REG = address;
 874   1          }
 875          
 876          
 877              /*******************************************************************************
 878              * Function Name: UART_SetRxAddress2
 879              ********************************************************************************
 880              *
 881              * Summary:
 882              *  Set the second hardware address compare value
 883              *
 884              * Parameters:
 885              *  address
 886              *
 887              * Return:
 888              *  None.
 889              *
 890              *******************************************************************************/
 891              void UART_SetRxAddress2(uint8 address) 
 892              {
 893   1              UART_RXADDRESS2_REG = address;
 894   1          }
 895                  
 896          #endif  /* UART_RX_ENABLED || UART_HD_ENABLED*/
 897          
 898          
 899          #if( (UART_TX_ENABLED) || (UART_HD_ENABLED) )
 900          
 901              #if(UART_TX_INTERRUPT_ENABLED)
 902          
 903                  /*******************************************************************************
 904                  * Function Name: UART_EnableTxInt
 905                  ********************************************************************************
 906                  *
 907                  * Summary:
 908                  *  Enable TX interrupt generation
 909                  *
 910                  * Parameters:
 911                  *  None.
 912                  *
 913                  * Return:
 914                  *  None.
 915                  *
 916                  * Theory:
 917                  *  Enable the interrupt output -or- the interrupt component itself
 918                  *
 919                  *******************************************************************************/
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 16  

 920                  void UART_EnableTxInt(void) 
 921                  {
 922   1                  CyIntEnable(UART_TX_VECT_NUM);
 923   1              }
 924          
 925          
 926                  /*******************************************************************************
 927                  * Function Name: UART_DisableTxInt
 928                  ********************************************************************************
 929                  *
 930                  * Summary:
 931                  *  Disable TX interrupt generation
 932                  *
 933                  * Parameters:
 934                  *  None.
 935                  *
 936                  * Return:
 937                  *  None.
 938                  *
 939                  * Theory:
 940                  *  Disable the interrupt output -or- the interrupt component itself
 941                  *
 942                  *******************************************************************************/
 943                  void UART_DisableTxInt(void) 
 944                  {
 945   1                  CyIntDisable(UART_TX_VECT_NUM);
 946   1              }
 947          
 948              #endif /* UART_TX_INTERRUPT_ENABLED */
 949          
 950          
 951              /*******************************************************************************
 952              * Function Name: UART_SetTxInterruptMode
 953              ********************************************************************************
 954              *
 955              * Summary:
 956              *  Configure which status bits trigger an interrupt event
 957              *
 958              * Parameters:
 959              *  intSrc: An or'd combination of the desired status bit masks (defined in
 960              *          the header file)
 961              *
 962              * Return:
 963              *  None.
 964              *
 965              * Theory:
 966              *  Enables the output of specific status bits to the interrupt controller
 967              *
 968              *******************************************************************************/
 969              void UART_SetTxInterruptMode(uint8 intSrc) 
 970              {
 971   1              UART_TXSTATUS_MASK_REG = intSrc;
 972   1          }
 973          
 974          
 975              /*******************************************************************************
 976              * Function Name: UART_WriteTxData
 977              ********************************************************************************
 978              *
 979              * Summary:
 980              *  Write a byte of data to the Transmit FIFO or TX buffer to be sent when the 
 981              *  bus is available. WriteTxData sends a byte without checking for buffer room 
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 17  

 982              *  or status. It is up to the user to separately check status.    
 983              *
 984              * Parameters:
 985              *  TXDataByte: byte of data to place in the transmit FIFO
 986              *
 987              * Return:
 988              * void
 989              *
 990              * Global Variables:
 991              *  UART_txBuffer - RAM buffer pointer for save data for transmission
 992              *  UART_txBufferWrite - cyclic index for write to txBuffer, 
 993              *    incremented after each byte saved to buffer.
 994              *  UART_txBufferRead - cyclic index for read from txBuffer, 
 995              *    checked to identify the condition to write to FIFO directly or to TX buffer
 996              *  UART_initVar - checked to identify that the component has been  
 997              *    initialized.
 998              *
 999              * Reentrant:
1000              *  No.
1001              *
1002              *******************************************************************************/
1003              void UART_WriteTxData(uint8 txDataByte) 
1004              {
1005   1              /* If not Initialized then skip this function*/
1006   1              if(UART_initVar != 0u)
1007   1              {
1008   2                  #if(UART_TXBUFFERSIZE > UART_FIFO_LENGTH)
1009   2      
1010   2                      /* Disable Tx interrupt. */
1011   2                      /* Protect variables that could change on interrupt. */
1012   2                      #if(UART_TX_INTERRUPT_ENABLED)
1013   2                          UART_DisableTxInt();
1014   2                      #endif /* End UART_TX_INTERRUPT_ENABLED */
1015   2      
1016   2                      if( (UART_txBufferRead == UART_txBufferWrite) &&
1017   2                         !(UART_TXSTATUS_REG & UART_TX_STS_FIFO_FULL) )
1018   2                      {
1019   3                          /* Add directly to the FIFO. */
1020   3                          UART_TXDATA_REG = txDataByte;
1021   3                      }
1022   2                      else
1023   2                      {
1024   3                          if(UART_txBufferWrite >= UART_TXBUFFERSIZE)
1025   3                          {
1026   4                              UART_txBufferWrite = 0;
1027   4                          }
1028   3      
1029   3                          UART_txBuffer[UART_txBufferWrite] = txDataByte;
1030   3      
1031   3                          /* Add to the software buffer. */
1032   3                          UART_txBufferWrite++;
1033   3      
1034   3                      }
1035   2      
1036   2                      /* Enable Tx interrupt. */
1037   2                      #if(UART_TX_INTERRUPT_ENABLED)
1038   2                          UART_EnableTxInt();
1039   2                      #endif /* End UART_TX_INTERRUPT_ENABLED */
1040   2      
1041   2                  #else /* UART_TXBUFFERSIZE > UART_FIFO_LENGTH */
              
                              /* Add directly to the FIFO. */
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 18  

                              UART_TXDATA_REG = txDataByte;
              
                          #endif /* End UART_TXBUFFERSIZE > UART_FIFO_LENGTH */
1047   2              }
1048   1          }
1049          
1050          
1051              /*******************************************************************************
1052              * Function Name: UART_ReadTxStatus
1053              ********************************************************************************
1054              *
1055              * Summary:
1056              *  Read the status register for the component
1057              *
1058              * Parameters:
1059              *  None.
1060              *
1061              * Return:
1062              *  Contents of the status register
1063              *
1064              * Theory:
1065              *  This function reads the status register which is clear on read. It is up to 
1066              *  the user to handle all bits in this return value accordingly, even if the bit 
1067              *  was not enabled as an interrupt source the event happened and must be handled
1068              *  accordingly.    
1069              *
1070              *******************************************************************************/
1071              uint8 UART_ReadTxStatus(void) 
1072              {
1073   1              return(UART_TXSTATUS_REG);
1074   1          }
1075          
1076          
1077              /*******************************************************************************
1078              * Function Name: UART_PutChar
1079              ********************************************************************************
1080              *
1081              * Summary:
1082              *  Wait to send byte until TX register or buffer has room.
1083              *
1084              * Parameters:
1085              *  txDataByte: The 8-bit data value to send across the UART.
1086              *
1087              * Return:
1088              *  None.
1089              *
1090              * Global Variables:
1091              *  UART_txBuffer - RAM buffer pointer for save data for transmission
1092              *  UART_txBufferWrite - cyclic index for write to txBuffer, 
1093              *     checked to identify free space in txBuffer and incremented after each byte 
1094              *     saved to buffer.
1095              *  UART_txBufferRead - cyclic index for read from txBuffer, 
1096              *     checked to identify free space in txBuffer.
1097              *  UART_initVar - checked to identify that the component has been  
1098              *     initialized.
1099              *
1100              * Reentrant:
1101              *  No.
1102              *
1103              * Theory:
1104              *  Allows the user to transmit any byte of data in a single transfer
1105              *
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 19  

1106              *******************************************************************************/
1107              void UART_PutChar(uint8 txDataByte) 
1108              {
1109   1                  #if(UART_TXBUFFERSIZE > UART_FIFO_LENGTH)
1110   1      
1111   1                      /* Block if buffer is full, so we dont overwrite. */
1112   1                      while( UART_txBufferWrite == (UART_txBufferRead - 1u) ||
1113   1                          (uint8)(UART_txBufferWrite - UART_txBufferRead) ==
1114   1                          (uint8)(UART_TXBUFFERSIZE - 1u) )
1115   1                      {
1116   2                          /* Software buffer is full. */
1117   2                      }
1118   1                      /* Disable Tx interrupt. */
1119   1                      /* Protect variables that could change on interrupt. */
1120   1                      #if(UART_TX_INTERRUPT_ENABLED)
1121   1                          UART_DisableTxInt();
1122   1                      #endif /* End UART_TX_INTERRUPT_ENABLED */
1123   1      
1124   1                      if( (UART_txBufferRead == UART_txBufferWrite) &&
1125   1                         !(UART_TXSTATUS_REG & UART_TX_STS_FIFO_FULL) )
1126   1                      {
1127   2                          /* Add directly to the FIFO. */
1128   2                          UART_TXDATA_REG = txDataByte;
1129   2                      }
1130   1                      else
1131   1                      {
1132   2                          if(UART_txBufferWrite >= UART_TXBUFFERSIZE)
1133   2                          {
1134   3                              UART_txBufferWrite = 0;
1135   3                          }
1136   2      
1137   2                          UART_txBuffer[UART_txBufferWrite] = txDataByte;
1138   2      
1139   2                          /* Add to the software buffer. */
1140   2                          UART_txBufferWrite++;
1141   2      
1142   2                      }
1143   1      
1144   1                      /* Enable Rx interrupt. */
1145   1                      #if(UART_TX_INTERRUPT_ENABLED)
1146   1                          UART_EnableTxInt();
1147   1                      #endif /* End UART_TX_INTERRUPT_ENABLED */
1148   1      
1149   1                  #else /* UART_TXBUFFERSIZE > UART_FIFO_LENGTH */
              
                              /* Block if there isnt room. */
                              while(UART_TXSTATUS_REG & UART_TX_STS_FIFO_FULL);
              
                              /* Add directly to the FIFO. */
                              UART_TXDATA_REG = txDataByte;
              
                          #endif /* End UART_TXBUFFERSIZE > UART_FIFO_LENGTH */
1158   1          }
1159          
1160          
1161              /*******************************************************************************
1162              * Function Name: UART_PutString
1163              ********************************************************************************
1164              *
1165              * Summary:
1166              *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1167              *
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 20  

1168              * Parameters:
1169              *  string: char pointer to character string of Data to Send.
1170              *
1171              * Return:
1172              *  None.
1173              *
1174              * Global Variables:
1175              *  UART_initVar - checked to identify that the component has been  
1176              *     initialized.
1177              *
1178              * Reentrant:
1179              *  No.
1180              *
1181              * Theory:
1182              *  This function will block if there is not enough memory to place the whole 
1183              *  string, it will block until the entire string has been written to the 
1184              *  transmit buffer.
1185              *
1186              *******************************************************************************/
1187              void UART_PutString(char* string) 
1188              {
1189   1              /* If not Initialized then skip this function*/
1190   1              if(UART_initVar != 0u)
1191   1              {
1192   2                  /* This is a blocking function, it will not exit until all data is sent*/
1193   2                  while(*string != 0u)
1194   2                  {
1195   3                      UART_PutChar(*string++);
1196   3                  }
1197   2              }
1198   1          }
1199          
1200          
1201              /*******************************************************************************
1202              * Function Name: UART_PutArray
1203              ********************************************************************************
1204              *
1205              * Summary:
1206              *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1207              *
1208              * Parameters:
1209              *  string: Address of the memory array residing in RAM or ROM.
1210              *  byteCount: Number of Bytes to be transmitted.
1211              *
1212              * Return:
1213              *  None.
1214              *
1215              * Global Variables:
1216              *  UART_initVar - checked to identify that the component has been  
1217              *     initialized.
1218              *
1219              * Reentrant:
1220              *  No.
1221              *
1222              *******************************************************************************/
1223              void UART_PutArray(uint8* string, uint8 byteCount) 
1224                                                                              
1225              {
1226   1              /* If not Initialized then skip this function*/
1227   1              if(UART_initVar != 0u)
1228   1              {
1229   2                  while(byteCount > 0u)
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 21  

1230   2                  {
1231   3                      UART_PutChar(*string++);
1232   3                      byteCount--;
1233   3                  }
1234   2              }
1235   1          }
1236          
1237          
1238              /*******************************************************************************
1239              * Function Name: UART_PutCRLF
1240              ********************************************************************************
1241              *
1242              * Summary:
1243              *  Write a character and then carriage return and line feed.
1244              *
1245              * Parameters:
1246              *  txDataByte: uint8 Character to send.
1247              *
1248              * Return:
1249              *  None.
1250              *
1251              * Global Variables:
1252              *  UART_initVar - checked to identify that the component has been  
1253              *     initialized.
1254              *
1255              * Reentrant:
1256              *  No.
1257              *
1258              *******************************************************************************/
1259              void UART_PutCRLF(uint8 txDataByte) 
1260              {
1261   1              /* If not Initialized then skip this function*/
1262   1              if(UART_initVar != 0u)
1263   1              {
1264   2                  UART_PutChar(txDataByte);
1265   2                  UART_PutChar(0x0Du);
1266   2                  UART_PutChar(0x0Au);
1267   2              }
1268   1          }
1269          
1270          
1271              /*******************************************************************************
1272              * Function Name: UART_GetTxBufferSize
1273              ********************************************************************************
1274              *
1275              * Summary:
1276              *  Determine the amount of space left in the TX buffer and return the count in
1277              *  bytes
1278              *
1279              * Parameters:
1280              *  None.
1281              *
1282              * Return:
1283              *  Integer count of the number of bytes left in the TX buffer
1284              *
1285              * Global Variables:
1286              *  UART_txBufferWrite - used to calculate left space. 
1287              *  UART_txBufferRead - used to calculate left space.
1288              *
1289              * Reentrant:
1290              *  No.
1291              *
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 22  

1292              * Theory:
1293              *  Allows the user to find out how full the TX Buffer is.
1294              *
1295              *******************************************************************************/
1296              uint8 UART_GetTxBufferSize(void) 
1297                                                                      
1298              {
1299   1              uint8 size;
1300   1      
1301   1              #if(UART_TXBUFFERSIZE > UART_FIFO_LENGTH)
1302   1      
1303   1                  /* Disable Tx interrupt. */
1304   1                  /* Protect variables that could change on interrupt. */
1305   1                  #if(UART_TX_INTERRUPT_ENABLED)
1306   1                      UART_DisableTxInt();
1307   1                  #endif /* End UART_TX_INTERRUPT_ENABLED */
1308   1      
1309   1                  if(UART_txBufferRead == UART_txBufferWrite)
1310   1                  {
1311   2                      size = 0u;
1312   2                  }
1313   1                  else if(UART_txBufferRead < UART_txBufferWrite)
1314   1                  {
1315   2                      size = (UART_txBufferWrite - UART_txBufferRead);
1316   2                  }
1317   1                  else
1318   1                  {
1319   2                      size = (UART_TXBUFFERSIZE - UART_txBufferRead) + UART_txBufferWrite;
1320   2                  }
1321   1      
1322   1                  /* Enable Tx interrupt. */
1323   1                  #if(UART_TX_INTERRUPT_ENABLED)
1324   1                      UART_EnableTxInt();
1325   1                  #endif /* End UART_TX_INTERRUPT_ENABLED */
1326   1      
1327   1              #else /* UART_TXBUFFERSIZE > UART_FIFO_LENGTH */
              
                          size = UART_TXSTATUS_REG;
              
                          /* Is the fifo is full. */
                          if(size & UART_TX_STS_FIFO_FULL)
                          {
                              size = UART_FIFO_LENGTH;
                          }
                          else if(size & UART_TX_STS_FIFO_EMPTY)
                          {
                              size = 0u;
                          }
                          else
                          {
                              /* We only know there is data in the fifo. */
                              size = 1u;
                          }
              
                      #endif /* End UART_TXBUFFERSIZE > UART_FIFO_LENGTH */
1347   1      
1348   1              return(size);
1349   1          }
1350          
1351          
1352              /*******************************************************************************
1353              * Function Name: UART_ClearTxBuffer
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 23  

1354              ********************************************************************************
1355              *
1356              * Summary:
1357              *  Clears the TX RAM buffer by setting the read and write pointers both to zero.
1358              *  Clears the hardware TX FIFO.  Any data present in the FIFO will not be sent.
1359              *
1360              * Parameters:
1361              *  None.
1362              *
1363              * Return:
1364              *  None.
1365              *
1366              * Global Variables:
1367              *  UART_txBufferWrite - cleared to zero. 
1368              *  UART_txBufferRead - cleared to zero.
1369              *
1370              * Reentrant:
1371              *  No.
1372              *
1373              * Theory:
1374              *  Setting the pointers to zero makes the system believe there is no data to 
1375              *  read and writing will resume at address 0 overwriting any data that may have
1376              *  remained in the RAM.
1377              *
1378              * Side Effects:
1379              *  Any received data not read from the RAM buffer will be lost when overwritten.
1380              *
1381              *******************************************************************************/
1382              void UART_ClearTxBuffer(void) 
1383              {
1384   1              uint8 enableInterrupts;
1385   1              
1386   1              /* Enter critical section */
1387   1              enableInterrupts = CyEnterCriticalSection();        
1388   1              /* clear the HW FIFO */
1389   1              UART_TXDATA_AUX_CTL_REG |=  UART_TX_FIFO_CLR;
1390   1              UART_TXDATA_AUX_CTL_REG &= ~UART_TX_FIFO_CLR;
1391   1              /* Exit critical section */
1392   1              CyExitCriticalSection(enableInterrupts);
1393   1      
1394   1              #if(UART_TXBUFFERSIZE > UART_FIFO_LENGTH)
1395   1      
1396   1                  /* Disable Tx interrupt. */
1397   1                  /* Protect variables that could change on interrupt. */
1398   1                  #if(UART_TX_INTERRUPT_ENABLED)
1399   1                      UART_DisableTxInt();
1400   1                  #endif /* End UART_TX_INTERRUPT_ENABLED */
1401   1      
1402   1                  UART_txBufferRead = 0u;
1403   1                  UART_txBufferWrite = 0u;
1404   1      
1405   1                  /* Enable Tx interrupt. */
1406   1                  #if(UART_TX_INTERRUPT_ENABLED)
1407   1                      UART_EnableTxInt();
1408   1                  #endif /* End UART_TX_INTERRUPT_ENABLED */
1409   1      
1410   1              #endif /* End UART_TXBUFFERSIZE > UART_FIFO_LENGTH */
1411   1          }
1412          
1413          
1414              /*******************************************************************************
1415              * Function Name: UART_SendBreak
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 24  

1416              ********************************************************************************
1417              *
1418              * Summary:
1419              *  Write a Break command to the UART
1420              *
1421              * Parameters:
1422              *  uint8 retMode:  Wait mode,
1423              *   0 - Initialize registers for Break, sends the Break signal and return 
1424              *       imediately.
1425              *   1 - Wait until Break sending is complete, reinitialize registers to normal
1426              *       transmission mode then return.
1427              *   2 - Reinitialize registers to normal transmission mode then return.
1428              *   3 - both steps: 0 and 1
1429              *       init registers for Break, send Break signal
1430              *       wait until Break sending is complete, reinit registers to normal
1431              *       transmission mode then return.
1432              *
1433              * Return:
1434              *  None.
1435              *
1436              * Global Variables:
1437              *  UART_initVar - checked to identify that the component has been  
1438              *     initialized.
1439              *  tx_period - static variable, used for keeping TX period configuration.
1440              *
1441              * Reentrant:
1442              *  No.
1443              *
1444              * Theory:
1445              *  SendBreak function initializes registers to send 13-bit break signal. It is
1446              *  important to return the registers configuration to normal for continue 8-bit
1447              *  operation.
1448              *  Trere are 3 variants for this API usage:
1449              *  1) SendBreak(3) - function will send the Break signal and take care on the
1450              *     configuration returning. Funcition will block CPU untill transmition 
1451              *     complete.
1452              *  2) User may want to use bloking time if UART configured to the low speed 
1453              *     operation
1454              *     Emample for this case:
1455              *     SendBreak(0);     - init Break signal transmition
1456              *         Add your code here to use CPU time
1457              *     SendBreak(1);     - complete Break operation
1458              *  3) Same to 2) but user may want to init and use the interrupt for complete 
1459              *     break operation.
1460              *     Example for this case:
1461              *     Init TX interrupt whith "TX - On TX Complete" parameter
1462              *     SendBreak(0);     - init Break signal transmition
1463              *         Add your code here to use CPU time
1464              *     When interrupt appear with UART_TX_STS_COMPLETE status:
1465              *     SendBreak(2);     - complete Break operation
1466              *
1467              * Side Effects:
1468              *   Uses static variable to keep registers configuration.
1469              *
1470              *******************************************************************************/
1471              void UART_SendBreak(uint8 retMode) 
1472              {
1473   1      
1474   1              /* If not Initialized then skip this function*/
1475   1              if(UART_initVar != 0u)
1476   1              {
1477   2                  /*Set the Counter to 13-bits and transmit a 00 byte*/
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 25  

1478   2                  /*When that is done then reset the counter value back*/
1479   2                  uint8 tmpStat;
1480   2      
1481   2                  #if(UART_HD_ENABLED) /* Half Duplex mode*/
              
                              if( (retMode == UART_SEND_BREAK) ||
                                  (retMode == UART_SEND_WAIT_REINIT ) )
                              {
                                  /* CTRL_HD_SEND_BREAK - sends break bits in HD mode*/
                                  UART_WriteControlRegister(UART_ReadControlRegister() |
                                                                        UART_CTRL_HD_SEND_BREAK);
                                  /* Send zeros*/
                                  UART_TXDATA_REG = 0u;
              
                                  do /*wait until transmit starts*/
                                  {
                                      tmpStat = UART_TXSTATUS_REG;
                                  }while(tmpStat & UART_TX_STS_FIFO_EMPTY);
                              }
              
                              if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
                                  (retMode == UART_SEND_WAIT_REINIT) )
                              {
                                  do /*wait until transmit complete*/
                                  {
                                      tmpStat = UART_TXSTATUS_REG;
                                  }while(~tmpStat & UART_TX_STS_COMPLETE);
                              }
              
                              if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
                                  (retMode == UART_REINIT) ||
                                  (retMode == UART_SEND_WAIT_REINIT) )
                              {
                                  UART_WriteControlRegister(UART_ReadControlRegister() &
                                                                       ~UART_CTRL_HD_SEND_BREAK);
                              }
              
                          #else /* UART_HD_ENABLED Full Duplex mode */
1516   2      
1517   2                      static uint8 tx_period; 
1518   2                      
1519   2                      if( (retMode == UART_SEND_BREAK) ||
1520   2                          (retMode == UART_SEND_WAIT_REINIT) )
1521   2                      {
1522   3                          /* CTRL_HD_SEND_BREAK - skip to send parity bit @ Break signal in Full Duplex mode*/
1523   3                          if( (UART_PARITY_TYPE != UART__B_UART__NONE_REVB) ||
1524   3                               UART_PARITY_TYPE_SW )
1525   3                          {
1526   4                              UART_WriteControlRegister(UART_ReadControlRegister() |
1527   4                                                                    UART_CTRL_HD_SEND_BREAK);
1528   4                          }                                                          
1529   3      
1530   3                          #if(UART_TXCLKGEN_DP)
1531   3                              tx_period = UART_TXBITCLKTX_COMPLETE_REG;
1532   3                              UART_TXBITCLKTX_COMPLETE_REG = UART_TXBITCTR_BREAKBITS;
1533   3                          #else
                                      tx_period = UART_TXBITCTR_PERIOD_REG;
                                      UART_TXBITCTR_PERIOD_REG = UART_TXBITCTR_BREAKBITS8X;
                                  #endif /* End UART_TXCLKGEN_DP */
1537   3      
1538   3                          /* Send zeros*/
1539   3                          UART_TXDATA_REG = 0u;
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 26  

1540   3      
1541   3                          do /*wait until transmit starts*/
1542   3                          {
1543   4                              tmpStat = UART_TXSTATUS_REG;
1544   4                          }while(tmpStat & UART_TX_STS_FIFO_EMPTY);
1545   3                      }
1546   2      
1547   2                      if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
1548   2                          (retMode == UART_SEND_WAIT_REINIT) )
1549   2                      {
1550   3                          do /*wait until transmit complete*/
1551   3                          {
1552   4                              tmpStat = UART_TXSTATUS_REG;
1553   4                          }while(~tmpStat & UART_TX_STS_COMPLETE);
1554   3                      }
1555   2      
1556   2                      if( (retMode == UART_WAIT_FOR_COMPLETE_REINIT) ||
1557   2                          (retMode == UART_REINIT) ||
1558   2                          (retMode == UART_SEND_WAIT_REINIT) )
1559   2                      {
1560   3      
1561   3                          #if(UART_TXCLKGEN_DP)
1562   3                              UART_TXBITCLKTX_COMPLETE_REG = tx_period;
1563   3                          #else
                                      UART_TXBITCTR_PERIOD_REG = tx_period;
                                  #endif /* End UART_TXCLKGEN_DP */
1566   3      
1567   3                          if( (UART_PARITY_TYPE != UART__B_UART__NONE_REVB) || 
1568   3                               UART_PARITY_TYPE_SW )
1569   3                          {
1570   4                              UART_WriteControlRegister(UART_ReadControlRegister() &
1571   4                                                                   ~UART_CTRL_HD_SEND_BREAK);
1572   4                          }                                     
1573   3                      }
1574   2                  #endif    /* End UART_HD_ENABLED */
1575   2              }
1576   1          }
1577          
1578          
1579              /*******************************************************************************
1580              * Function Name: UART_SetTxAddressMode
1581              ********************************************************************************
1582              *
1583              * Summary:
1584              *  Set the transmit addressing mode
1585              *
1586              * Parameters:
1587              *  addressMode: 0 -> Space
1588              *               1 -> Mark
1589              *
1590              * Return:
1591              *  None.
1592              *
1593              *******************************************************************************/
1594              void UART_SetTxAddressMode(uint8 addressMode) 
1595              {
1596   1              /* Mark/Space sending enable*/
1597   1              if(addressMode != 0)
1598   1              {
1599   2                  UART_WriteControlRegister(UART_ReadControlRegister() | UART_CTRL_MARK);
1600   2              }
1601   1              else
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 27  

1602   1              {
1603   2                  UART_WriteControlRegister(UART_ReadControlRegister() & ~UART_CTRL_MARK);
1604   2              }
1605   1          }
1606          
1607          #endif  /* EndUART_TX_ENABLED */
1608          
1609          #if(UART_HD_ENABLED)
              
              
                  /*******************************************************************************
                  * Function Name: UART_LoadTxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Unloads the Rx configuration if required and loads the
                  *  Tx configuration. It is the users responsibility to ensure that any
                  *  transaction is complete and it is safe to unload the Tx
                  *  configuration.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
                  *  Valid only for half duplex UART. 
                  *
                  * Side Effects:
                  *  Disable RX interrupt mask, when software buffer has been used.
                  *
                  *******************************************************************************/
                  void UART_LoadTxConfig(void) 
                  {
                      #if((UART_RX_INTERRUPT_ENABLED) && (UART_RXBUFFERSIZE > UART_FIFO_LENGTH))
                          /* Disable RX interrupts before set TX configuration */
                          UART_SetRxInterruptMode(0);
                      #endif /* UART_RX_INTERRUPT_ENABLED */
              
                      UART_WriteControlRegister(UART_ReadControlRegister() | UART_CTRL_HD_SEND);
                      UART_RXBITCTR_PERIOD_REG = UART_HD_TXBITCTR_INIT;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_LoadRxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Unloads the Tx configuration if required and loads the
                  *  Rx configuration. It is the users responsibility to ensure that any
                  *  transaction is complete and it is safe to unload the Rx
                  *  configuration.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 28  

                  *  Valid only for half duplex UART
                  *
                  * Side Effects:
                  *  Set RX interrupt mask based on customizer settings, when software buffer 
                  *  has been used.
                  *
                  *******************************************************************************/
                  void UART_LoadRxConfig(void) 
                  {
                      #if((UART_RX_INTERRUPT_ENABLED) && (UART_RXBUFFERSIZE > UART_FIFO_LENGTH))
                          /* Enable RX interrupt mask before set RX configuration */
                          UART_SetRxInterruptMode(UART_INIT_RX_INTERRUPTS_MASK);    
                      #endif /* UART_RX_INTERRUPT_ENABLED */
                      
                      UART_WriteControlRegister(UART_ReadControlRegister() & ~UART_CTRL_HD_SEND);
                      UART_RXBITCTR_PERIOD_REG = UART_HD_RXBITCTR_INIT;
                  }
              
              #endif  /* UART_HD_ENABLED */
1683          
1684          
1685          /* [] END OF FILE */
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 29  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION UART_Start (BEGIN)
                                           ; SOURCE LINE # 77
                                           ; SOURCE LINE # 78
                                           ; SOURCE LINE # 80
0000 900000      R     MOV     DPTR,#UART_initVar
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 7009              JNZ     ?C0001
                                           ; SOURCE LINE # 81
                                           ; SOURCE LINE # 82
0008 120000      R     LCALL   UART_Init
                                           ; SOURCE LINE # 83
000B 900000      R     MOV     DPTR,#UART_initVar
000E 7401              MOV     A,#01H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 84
0011         ?C0001:
                                           ; SOURCE LINE # 85
0011 120000      R     LCALL   UART_Enable
                                           ; SOURCE LINE # 86
0014 22                RET     
             ; FUNCTION UART_Start (END)

             ; FUNCTION UART_Init (BEGIN)
                                           ; SOURCE LINE # 105
                                           ; SOURCE LINE # 106
                                           ; SOURCE LINE # 111
0000 7C00        E     MOV     R4,#HIGH UART_RXISR
0002 7D00        E     MOV     R5,#LOW UART_RXISR
0004 7F07              MOV     R7,#07H
0006 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 112
0009 7D07              MOV     R5,#07H
000B 7F07              MOV     R7,#07H
000D 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 122
0010 906483            MOV     DPTR,#06483H
0013 7420              MOV     A,#020H
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 128
0016 7C00        E     MOV     R4,#HIGH UART_TXISR
0018 7D00        E     MOV     R5,#LOW UART_TXISR
001A 7F17              MOV     R7,#017H
001C 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 129
001F 7D07              MOV     R5,#07H
0021 7F17              MOV     R7,#017H
0023 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 134
0026 906427            MOV     DPTR,#06427H
0029 740F              MOV     A,#0FH
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 135
002C 906437            MOV     DPTR,#06437H
002F 7490              MOV     A,#090H
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 146
0032 906487            MOV     DPTR,#06487H
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 30  

0035 7402              MOV     A,#02H
0037 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 158
0038 22                RET     
             ; FUNCTION UART_Init (END)

             ; FUNCTION UART_Enable (BEGIN)
                                           ; SOURCE LINE # 178
                                           ; SOURCE LINE # 179
                                           ; SOURCE LINE # 181
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 185
0008 906494            MOV     DPTR,#06494H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4420              ORL     A,#020H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 187
0013 906493            MOV     DPTR,#06493H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 4410              ORL     A,#010H
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 189
001E 7F07              MOV     R7,#07H
0020 120000      E     LCALL   _?CyIntEnable
                                           ; SOURCE LINE # 202
0023 906497            MOV     DPTR,#06497H
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
0028 EF                MOV     A,R7
0029 4410              ORL     A,#010H
002B FF                MOV     R7,A
002C EF                MOV     A,R7
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 204
002E 7F17              MOV     R7,#017H
0030 120000      E     LCALL   _?CyIntEnable
                                           ; SOURCE LINE # 213
0033 900000      R     MOV     DPTR,#enableInterrupts
0036 E0                MOVX    A,@DPTR
0037 FF                MOV     R7,A
0038 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 214
003B 22                RET     
             ; FUNCTION UART_Enable (END)

             ; FUNCTION UART_Stop (BEGIN)
                                           ; SOURCE LINE # 231
                                           ; SOURCE LINE # 232
                                           ; SOURCE LINE # 234
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 31  

0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 238
0008 906494            MOV     DPTR,#06494H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 54DF              ANL     A,#0DFH
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 254
0013 906493            MOV     DPTR,#06493H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54EF              ANL     A,#0EFH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 256
001E 120000      R     LCALL   UART_DisableRxInt
                                           ; SOURCE LINE # 261
0021 906497            MOV     DPTR,#06497H
0024 E0                MOVX    A,@DPTR
0025 FF                MOV     R7,A
0026 EF                MOV     A,R7
0027 54EF              ANL     A,#0EFH
0029 FF                MOV     R7,A
002A EF                MOV     A,R7
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 263
002C 120000      R     LCALL   UART_DisableTxInt
                                           ; SOURCE LINE # 267
002F 900000      R     MOV     DPTR,#enableInterrupts
0032 E0                MOVX    A,@DPTR
0033 FF                MOV     R7,A
0034 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 268
0037 22                RET     
             ; FUNCTION UART_Stop (END)

             ; FUNCTION UART_ReadControlRegister (BEGIN)
                                           ; SOURCE LINE # 285
                                           ; SOURCE LINE # 286
                                           ; SOURCE LINE # 288
0000 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 292
0002         ?C0006:
0002 22                RET     
             ; FUNCTION UART_ReadControlRegister (END)

             ; FUNCTION _UART_WriteControlRegister (BEGIN)
                                           ; SOURCE LINE # 309
0000 900000      R     MOV     DPTR,#control
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 310
                                           ; SOURCE LINE # 312
0005 900000      R     MOV     DPTR,#control
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 32  

000A 900000      R     MOV     DPTR,#control
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 316
000F 22                RET     
             ; FUNCTION _UART_WriteControlRegister (END)

             ; FUNCTION UART_EnableRxInt (BEGIN)
                                           ; SOURCE LINE # 340
                                           ; SOURCE LINE # 341
                                           ; SOURCE LINE # 342
0000 7F07              MOV     R7,#07H
0002 120000      E     LCALL   _?CyIntEnable
                                           ; SOURCE LINE # 343
0005 22                RET     
             ; FUNCTION UART_EnableRxInt (END)

             ; FUNCTION UART_DisableRxInt (BEGIN)
                                           ; SOURCE LINE # 363
                                           ; SOURCE LINE # 364
                                           ; SOURCE LINE # 365
0000 7F07              MOV     R7,#07H
0002 120000      E     LCALL   _?CyIntDisable
                                           ; SOURCE LINE # 366
0005 22                RET     
             ; FUNCTION UART_DisableRxInt (END)

             ; FUNCTION _UART_SetRxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 389
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 390
                                           ; SOURCE LINE # 391
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906483            MOV     DPTR,#06483H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 392
000F 22                RET     
             ; FUNCTION _UART_SetRxInterruptMode (END)

             ; FUNCTION UART_ReadRxData (BEGIN)
                                           ; SOURCE LINE # 422
                                           ; SOURCE LINE # 423
                                           ; SOURCE LINE # 431
0000 120000      R     LCALL   UART_DisableRxInt
                                           ; SOURCE LINE # 434
0003 900000      R     MOV     DPTR,#UART_rxBufferWrite
0006 E0                MOVX    A,@DPTR
0007 FF                MOV     R7,A
0008 900000      R     MOV     DPTR,#UART_rxBufferRead
000B E0                MOVX    A,@DPTR
000C FE                MOV     R6,A
000D EE                MOV     A,R6
000E B5070B            CJNE    A,AR7,?C0012
0011 900000      R     MOV     DPTR,#UART_rxBufferLoopDetect
0014 E0                MOVX    A,@DPTR
0015 FF                MOV     R7,A
0016 EF                MOV     A,R7
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 33  

0017 D3                SETB    C
0018 9400              SUBB    A,#00H
001A 403E              JC      ?C0011
001C         ?C0012:
                                           ; SOURCE LINE # 436
                                           ; SOURCE LINE # 438
001C 900000      R     MOV     DPTR,#UART_rxBufferRead
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
0021 7400        R     MOV     A,#LOW UART_rxBuffer
0023 2F                ADD     A,R7
0024 F582              MOV     DPL,A
0026 E4                CLR     A
0027 3400        R     ADDC    A,#HIGH UART_rxBuffer
0029 F583              MOV     DPH,A
002B E0                MOVX    A,@DPTR
002C FF                MOV     R7,A
002D 900000      R     MOV     DPTR,#rxData
0030 EF                MOV     A,R7
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 440
0032 900000      R     MOV     DPTR,#UART_rxBufferRead
0035 E0                MOVX    A,@DPTR
0036 04                INC     A
0037 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 442
0038 900000      R     MOV     DPTR,#UART_rxBufferRead
003B E0                MOVX    A,@DPTR
003C FF                MOV     R7,A
003D EF                MOV     A,R7
003E C3                CLR     C
003F 9420              SUBB    A,#020H
0041 4005              JC      ?C0013
                                           ; SOURCE LINE # 443
                                           ; SOURCE LINE # 444
0043 900000      R     MOV     DPTR,#UART_rxBufferRead
0046 E4                CLR     A
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 445
0048         ?C0013:
                                           ; SOURCE LINE # 447
0048 900000      R     MOV     DPTR,#UART_rxBufferLoopDetect
004B E0                MOVX    A,@DPTR
004C FF                MOV     R7,A
004D EF                MOV     A,R7
004E D3                SETB    C
004F 9400              SUBB    A,#00H
0051 4011              JC      ?C0015
                                           ; SOURCE LINE # 448
                                           ; SOURCE LINE # 449
0053 900000      R     MOV     DPTR,#UART_rxBufferLoopDetect
0056 E4                CLR     A
0057 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 464
                                           ; SOURCE LINE # 465
0058 800A              SJMP    ?C0015
005A         ?C0011:
                                           ; SOURCE LINE # 467
                                           ; SOURCE LINE # 468
005A 906444            MOV     DPTR,#06444H
005D E0                MOVX    A,@DPTR
005E FF                MOV     R7,A
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 34  

005F 900000      R     MOV     DPTR,#rxData
0062 EF                MOV     A,R7
0063 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 469
0064         ?C0015:
                                           ; SOURCE LINE # 473
0064 120000      R     LCALL   UART_EnableRxInt
                                           ; SOURCE LINE # 483
0067 900000      R     MOV     DPTR,#rxData
006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
                                           ; SOURCE LINE # 484
006C         ?C0016:
006C 22                RET     
             ; FUNCTION UART_ReadRxData (END)

             ; FUNCTION UART_ReadRxStatus (BEGIN)
                                           ; SOURCE LINE # 510
                                           ; SOURCE LINE # 511
                                           ; SOURCE LINE # 514
0000 906463            MOV     DPTR,#06463H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#status
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 515
000A 900000      R     MOV     DPTR,#status
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 547F              ANL     A,#07FH
0012 FF                MOV     R7,A
0013 900000      R     MOV     DPTR,#status
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 518
0018 900000      R     MOV     DPTR,#UART_rxBufferOverflow
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 6013              JZ      ?C0017
                                           ; SOURCE LINE # 519
                                           ; SOURCE LINE # 520
0020 900000      R     MOV     DPTR,#status
0023 E0                MOVX    A,@DPTR
0024 FF                MOV     R7,A
0025 EF                MOV     A,R7
0026 4480              ORL     A,#080H
0028 FF                MOV     R7,A
0029 900000      R     MOV     DPTR,#status
002C EF                MOV     A,R7
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 521
002E 900000      R     MOV     DPTR,#UART_rxBufferOverflow
0031 E4                CLR     A
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 522
0033         ?C0017:
                                           ; SOURCE LINE # 525
0033 900000      R     MOV     DPTR,#status
0036 E0                MOVX    A,@DPTR
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 35  

0037 FF                MOV     R7,A
                                           ; SOURCE LINE # 526
0038         ?C0018:
0038 22                RET     
             ; FUNCTION UART_ReadRxStatus (END)

             ; FUNCTION UART_GetChar (BEGIN)
                                           ; SOURCE LINE # 558
                                           ; SOURCE LINE # 559
                                           ; SOURCE LINE # 560
0000 900000      R     MOV     DPTR,#rxData
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 568
0005 120000      R     LCALL   UART_DisableRxInt
                                           ; SOURCE LINE # 571
0008 900000      R     MOV     DPTR,#UART_rxBufferWrite
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D 900000      R     MOV     DPTR,#UART_rxBufferRead
0010 E0                MOVX    A,@DPTR
0011 FE                MOV     R6,A
0012 EE                MOV     A,R6
0013 B5070B            CJNE    A,AR7,?C0020
0016 900000      R     MOV     DPTR,#UART_rxBufferLoopDetect
0019 E0                MOVX    A,@DPTR
001A FF                MOV     R7,A
001B EF                MOV     A,R7
001C D3                SETB    C
001D 9400              SUBB    A,#00H
001F 403E              JC      ?C0019
0021         ?C0020:
                                           ; SOURCE LINE # 573
                                           ; SOURCE LINE # 574
0021 900000      R     MOV     DPTR,#UART_rxBufferRead
0024 E0                MOVX    A,@DPTR
0025 FF                MOV     R7,A
0026 7400        R     MOV     A,#LOW UART_rxBuffer
0028 2F                ADD     A,R7
0029 F582              MOV     DPL,A
002B E4                CLR     A
002C 3400        R     ADDC    A,#HIGH UART_rxBuffer
002E F583              MOV     DPH,A
0030 E0                MOVX    A,@DPTR
0031 FF                MOV     R7,A
0032 900000      R     MOV     DPTR,#rxData
0035 EF                MOV     A,R7
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 576
0037 900000      R     MOV     DPTR,#UART_rxBufferRead
003A E0                MOVX    A,@DPTR
003B 04                INC     A
003C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 578
003D 900000      R     MOV     DPTR,#UART_rxBufferRead
0040 E0                MOVX    A,@DPTR
0041 FF                MOV     R7,A
0042 EF                MOV     A,R7
0043 C3                CLR     C
0044 9420              SUBB    A,#020H
0046 4005              JC      ?C0021
                                           ; SOURCE LINE # 579
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 36  

                                           ; SOURCE LINE # 580
0048 900000      R     MOV     DPTR,#UART_rxBufferRead
004B E4                CLR     A
004C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 581
004D         ?C0021:
                                           ; SOURCE LINE # 583
004D 900000      R     MOV     DPTR,#UART_rxBufferLoopDetect
0050 E0                MOVX    A,@DPTR
0051 FF                MOV     R7,A
0052 EF                MOV     A,R7
0053 D3                SETB    C
0054 9400              SUBB    A,#00H
0056 4035              JC      ?C0023
                                           ; SOURCE LINE # 584
                                           ; SOURCE LINE # 585
0058 900000      R     MOV     DPTR,#UART_rxBufferLoopDetect
005B E4                CLR     A
005C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 600
                                           ; SOURCE LINE # 602
005D 802E              SJMP    ?C0023
005F         ?C0019:
                                           ; SOURCE LINE # 604
005F 906463            MOV     DPTR,#06463H
0062 E0                MOVX    A,@DPTR
0063 FF                MOV     R7,A
0064 900000      R     MOV     DPTR,#rxStatus
0067 EF                MOV     A,R7
0068 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 605
0069 900000      R     MOV     DPTR,#rxStatus
006C E0                MOVX    A,@DPTR
006D FF                MOV     R7,A
006E EF                MOV     A,R7
006F 30E51B            JNB     ACC.5,?C0023
                                           ; SOURCE LINE # 606
                                           ; SOURCE LINE # 607
0072 906444            MOV     DPTR,#06444H
0075 E0                MOVX    A,@DPTR
0076 FF                MOV     R7,A
0077 900000      R     MOV     DPTR,#rxData
007A EF                MOV     A,R7
007B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 609
007C 900000      R     MOV     DPTR,#rxStatus
007F E0                MOVX    A,@DPTR
0080 FF                MOV     R7,A
0081 EF                MOV     A,R7
0082 541E              ANL     A,#01EH
0084 FF                MOV     R7,A
0085 EF                MOV     A,R7
0086 6005              JZ      ?C0023
                                           ; SOURCE LINE # 611
                                           ; SOURCE LINE # 612
0088 900000      R     MOV     DPTR,#rxData
008B E4                CLR     A
008C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 613
                                           ; SOURCE LINE # 614
                                           ; SOURCE LINE # 615
008D         ?C0023:
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 37  

                                           ; SOURCE LINE # 619
008D 120000      R     LCALL   UART_EnableRxInt
                                           ; SOURCE LINE # 637
0090 900000      R     MOV     DPTR,#rxData
0093 E0                MOVX    A,@DPTR
0094 FF                MOV     R7,A
                                           ; SOURCE LINE # 638
0095         ?C0026:
0095 22                RET     
             ; FUNCTION UART_GetChar (END)

             ; FUNCTION UART_GetByte (BEGIN)
                                           ; SOURCE LINE # 658
                                           ; SOURCE LINE # 659
                                           ; SOURCE LINE # 660
0000 120000      R     LCALL   UART_ReadRxStatus
0003 7E00              MOV     R6,#00H
0005 EF                MOV     A,R7
0006 7F00              MOV     R7,#00H
0008 FE                MOV     R6,A
0009 C006              PUSH    AR6
000B C007              PUSH    AR7
000D 120000      R     LCALL   UART_ReadRxData
0010 EF                MOV     A,R7
0011 FD                MOV     R5,A
0012 7C00              MOV     R4,#00H
0014 D007              POP     AR7
0016 D006              POP     AR6
0018 EE                MOV     A,R6
0019 4C                ORL     A,R4
001A FE                MOV     R6,A
001B EF                MOV     A,R7
001C 4D                ORL     A,R5
001D FF                MOV     R7,A
                                           ; SOURCE LINE # 661
001E         ?C0027:
001E 22                RET     
             ; FUNCTION UART_GetByte (END)

             ; FUNCTION UART_GetRxBufferSize (BEGIN)
                                           ; SOURCE LINE # 691
                                           ; SOURCE LINE # 693
                                           ; SOURCE LINE # 701
0000 120000      R     LCALL   UART_DisableRxInt
                                           ; SOURCE LINE # 704
0003 900000      R     MOV     DPTR,#UART_rxBufferWrite
0006 E0                MOVX    A,@DPTR
0007 FF                MOV     R7,A
0008 900000      R     MOV     DPTR,#UART_rxBufferRead
000B E0                MOVX    A,@DPTR
000C FE                MOV     R6,A
000D EE                MOV     A,R6
000E B5071A            CJNE    A,AR7,?C0028
                                           ; SOURCE LINE # 705
                                           ; SOURCE LINE # 706
0011 900000      R     MOV     DPTR,#UART_rxBufferLoopDetect
0014 E0                MOVX    A,@DPTR
0015 FF                MOV     R7,A
0016 EF                MOV     A,R7
0017 D3                SETB    C
0018 9400              SUBB    A,#00H
001A 4008              JC      ?C0029
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 38  

                                           ; SOURCE LINE # 707
                                           ; SOURCE LINE # 708
001C 900000      R     MOV     DPTR,#size
001F 7420              MOV     A,#020H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 709
0022 8042              SJMP    ?C0031
0024         ?C0029:
                                           ; SOURCE LINE # 711
                                           ; SOURCE LINE # 712
0024 900000      R     MOV     DPTR,#size
0027 E4                CLR     A
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 713
                                           ; SOURCE LINE # 714
0029 803B              SJMP    ?C0031
002B         ?C0028:
                                           ; SOURCE LINE # 715
002B 900000      R     MOV     DPTR,#UART_rxBufferWrite
002E E0                MOVX    A,@DPTR
002F FF                MOV     R7,A
0030 900000      R     MOV     DPTR,#UART_rxBufferRead
0033 E0                MOVX    A,@DPTR
0034 FE                MOV     R6,A
0035 EE                MOV     A,R6
0036 C3                CLR     C
0037 9F                SUBB    A,R7
0038 5015              JNC     ?C0032
                                           ; SOURCE LINE # 716
                                           ; SOURCE LINE # 717
003A 900000      R     MOV     DPTR,#UART_rxBufferRead
003D E0                MOVX    A,@DPTR
003E FF                MOV     R7,A
003F 900000      R     MOV     DPTR,#UART_rxBufferWrite
0042 E0                MOVX    A,@DPTR
0043 FE                MOV     R6,A
0044 C3                CLR     C
0045 EE                MOV     A,R6
0046 9F                SUBB    A,R7
0047 FF                MOV     R7,A
0048 900000      R     MOV     DPTR,#size
004B EF                MOV     A,R7
004C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 718
004D 8017              SJMP    ?C0031
004F         ?C0032:
                                           ; SOURCE LINE # 720
                                           ; SOURCE LINE # 721
004F 900000      R     MOV     DPTR,#UART_rxBufferRead
0052 E0                MOVX    A,@DPTR
0053 FF                MOV     R7,A
0054 C3                CLR     C
0055 7420              MOV     A,#020H
0057 9F                SUBB    A,R7
0058 FF                MOV     R7,A
0059 900000      R     MOV     DPTR,#UART_rxBufferWrite
005C E0                MOVX    A,@DPTR
005D FE                MOV     R6,A
005E EF                MOV     A,R7
005F 2E                ADD     A,R6
0060 FF                MOV     R7,A
0061 900000      R     MOV     DPTR,#size
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 39  

0064 EF                MOV     A,R7
0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 722
0066         ?C0031:
                                           ; SOURCE LINE # 726
0066 120000      R     LCALL   UART_EnableRxInt
                                           ; SOURCE LINE # 736
0069 900000      R     MOV     DPTR,#size
006C E0                MOVX    A,@DPTR
006D FF                MOV     R7,A
                                           ; SOURCE LINE # 737
006E         ?C0034:
006E 22                RET     
             ; FUNCTION UART_GetRxBufferSize (END)

             ; FUNCTION UART_ClearRxBuffer (BEGIN)
                                           ; SOURCE LINE # 771
                                           ; SOURCE LINE # 772
                                           ; SOURCE LINE # 777
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 778
0008 906494            MOV     DPTR,#06494H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 779
0013 906494            MOV     DPTR,#06494H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FE              ANL     A,#0FEH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 781
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 787
0026 120000      R     LCALL   UART_DisableRxInt
                                           ; SOURCE LINE # 790
0029 900000      R     MOV     DPTR,#UART_rxBufferRead
002C E4                CLR     A
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 791
002E 900000      R     MOV     DPTR,#UART_rxBufferWrite
0031 E4                CLR     A
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 792
0033 900000      R     MOV     DPTR,#UART_rxBufferLoopDetect
0036 E4                CLR     A
0037 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 793
0038 900000      R     MOV     DPTR,#UART_rxBufferOverflow
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 40  

003B E4                CLR     A
003C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 797
003D 120000      R     LCALL   UART_EnableRxInt
                                           ; SOURCE LINE # 801
0040 22                RET     
             ; FUNCTION UART_ClearRxBuffer (END)

             ; FUNCTION _UART_SetRxAddressMode (BEGIN)
                                           ; SOURCE LINE # 832
0000 900000      R     MOV     DPTR,#addressMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 834
                                           ; SOURCE LINE # 851
0005 900000      R     MOV     DPTR,#addressMode
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 900000      R     MOV     DPTR,#addressMode
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 853
000F 22                RET     
             ; FUNCTION _UART_SetRxAddressMode (END)

             ; FUNCTION _UART_SetRxAddress1 (BEGIN)
                                           ; SOURCE LINE # 870
0000 900000      R     MOV     DPTR,#address
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 872
                                           ; SOURCE LINE # 873
0005 900000      R     MOV     DPTR,#address
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906424            MOV     DPTR,#06424H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 874
000F 22                RET     
             ; FUNCTION _UART_SetRxAddress1 (END)

             ; FUNCTION _UART_SetRxAddress2 (BEGIN)
                                           ; SOURCE LINE # 891
0000 900000      R     MOV     DPTR,#address
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 892
                                           ; SOURCE LINE # 893
0005 900000      R     MOV     DPTR,#address
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906434            MOV     DPTR,#06434H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 894
000F 22                RET     
             ; FUNCTION _UART_SetRxAddress2 (END)

             ; FUNCTION UART_EnableTxInt (BEGIN)
                                           ; SOURCE LINE # 920
                                           ; SOURCE LINE # 921
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 41  

                                           ; SOURCE LINE # 922
0000 7F17              MOV     R7,#017H
0002 120000      E     LCALL   _?CyIntEnable
                                           ; SOURCE LINE # 923
0005 22                RET     
             ; FUNCTION UART_EnableTxInt (END)

             ; FUNCTION UART_DisableTxInt (BEGIN)
                                           ; SOURCE LINE # 943
                                           ; SOURCE LINE # 944
                                           ; SOURCE LINE # 945
0000 7F17              MOV     R7,#017H
0002 120000      E     LCALL   _?CyIntDisable
                                           ; SOURCE LINE # 946
0005 22                RET     
             ; FUNCTION UART_DisableTxInt (END)

             ; FUNCTION _UART_SetTxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 969
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 970
                                           ; SOURCE LINE # 971
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906487            MOV     DPTR,#06487H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 972
000F 22                RET     
             ; FUNCTION _UART_SetTxInterruptMode (END)

             ; FUNCTION _UART_WriteTxData (BEGIN)
                                           ; SOURCE LINE # 1003
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1004
                                           ; SOURCE LINE # 1006
0005 900000      R     MOV     DPTR,#UART_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 605B              JZ      ?C0046
                                           ; SOURCE LINE # 1007
                                           ; SOURCE LINE # 1013
000D 120000      R     LCALL   UART_DisableTxInt
                                           ; SOURCE LINE # 1017
0010 900000      R     MOV     DPTR,#UART_txBufferWrite
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 900000      R     MOV     DPTR,#UART_txBufferRead
0018 E0                MOVX    A,@DPTR
0019 FE                MOV     R6,A
001A EE                MOV     A,R6
001B B5071B            CJNE    A,AR7,?C0043
001E 906467            MOV     DPTR,#06467H
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 EF                MOV     A,R7
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 42  

0024 5404              ANL     A,#04H
0026 FF                MOV     R7,A
0027 7E00              MOV     R6,#00H
0029 EF                MOV     A,R7
002A 4E                ORL     A,R6
002B 700C              JNZ     ?C0043
                                           ; SOURCE LINE # 1018
                                           ; SOURCE LINE # 1020
002D 900000      R     MOV     DPTR,#txDataByte
0030 E0                MOVX    A,@DPTR
0031 FF                MOV     R7,A
0032 906547            MOV     DPTR,#06547H
0035 EF                MOV     A,R7
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1021
0037 802C              SJMP    ?C0044
0039         ?C0043:
                                           ; SOURCE LINE # 1023
                                           ; SOURCE LINE # 1024
0039 900000      R     MOV     DPTR,#UART_txBufferWrite
003C E0                MOVX    A,@DPTR
003D FF                MOV     R7,A
003E EF                MOV     A,R7
003F C3                CLR     C
0040 9420              SUBB    A,#020H
0042 4005              JC      ?C0045
                                           ; SOURCE LINE # 1025
                                           ; SOURCE LINE # 1026
0044 900000      R     MOV     DPTR,#UART_txBufferWrite
0047 E4                CLR     A
0048 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1027
0049         ?C0045:
                                           ; SOURCE LINE # 1029
0049 900000      R     MOV     DPTR,#txDataByte
004C E0                MOVX    A,@DPTR
004D FF                MOV     R7,A
004E 900000      R     MOV     DPTR,#UART_txBufferWrite
0051 E0                MOVX    A,@DPTR
0052 FE                MOV     R6,A
0053 7400        R     MOV     A,#LOW UART_txBuffer
0055 2E                ADD     A,R6
0056 F582              MOV     DPL,A
0058 E4                CLR     A
0059 3400        R     ADDC    A,#HIGH UART_txBuffer
005B F583              MOV     DPH,A
005D EF                MOV     A,R7
005E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1032
005F 900000      R     MOV     DPTR,#UART_txBufferWrite
0062 E0                MOVX    A,@DPTR
0063 04                INC     A
0064 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1034
0065         ?C0044:
                                           ; SOURCE LINE # 1038
0065 120000      R     LCALL   UART_EnableTxInt
                                           ; SOURCE LINE # 1047
                                           ; SOURCE LINE # 1048
0068         ?C0046:
0068 22                RET     
             ; FUNCTION _UART_WriteTxData (END)
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 43  


             ; FUNCTION UART_ReadTxStatus (BEGIN)
                                           ; SOURCE LINE # 1071
                                           ; SOURCE LINE # 1072
                                           ; SOURCE LINE # 1073
0000 906467            MOV     DPTR,#06467H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 1074
0005         ?C0047:
0005 22                RET     
             ; FUNCTION UART_ReadTxStatus (END)

             ; FUNCTION _UART_PutChar (BEGIN)
                                           ; SOURCE LINE # 1107
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1108
0005         ?C0048:
                                           ; SOURCE LINE # 1114
0005 900000      R     MOV     DPTR,#UART_txBufferRead
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 7E00              MOV     R6,#00H
000C EF                MOV     A,R7
000D 24FF              ADD     A,#0FFH
000F FF                MOV     R7,A
0010 EE                MOV     A,R6
0011 34FF              ADDC    A,#0FFH
0013 FE                MOV     R6,A
0014 900000      R     MOV     DPTR,#UART_txBufferWrite
0017 E0                MOVX    A,@DPTR
0018 FD                MOV     R5,A
0019 7C00              MOV     R4,#00H
001B EF                MOV     A,R7
001C 6D                XRL     A,R5
001D 7002              JNZ     ?C0090
001F EE                MOV     A,R6
0020 6C                XRL     A,R4
0021         ?C0090:
0021 60E2              JZ      ?C0048
0023 900000      R     MOV     DPTR,#UART_txBufferRead
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
0028 900000      R     MOV     DPTR,#UART_txBufferWrite
002B E0                MOVX    A,@DPTR
002C FE                MOV     R6,A
002D C3                CLR     C
002E EE                MOV     A,R6
002F 9F                SUBB    A,R7
0030 FF                MOV     R7,A
0031 EF                MOV     A,R7
0032 641F              XRL     A,#01FH
0034 60CF              JZ      ?C0048
                                           ; SOURCE LINE # 1115
                                           ; SOURCE LINE # 1117
0036         ?C0049:
                                           ; SOURCE LINE # 1121
0036 120000      R     LCALL   UART_DisableTxInt
                                           ; SOURCE LINE # 1125
0039 900000      R     MOV     DPTR,#UART_txBufferWrite
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 44  

003C E0                MOVX    A,@DPTR
003D FF                MOV     R7,A
003E 900000      R     MOV     DPTR,#UART_txBufferRead
0041 E0                MOVX    A,@DPTR
0042 FE                MOV     R6,A
0043 EE                MOV     A,R6
0044 B5071B            CJNE    A,AR7,?C0051
0047 906467            MOV     DPTR,#06467H
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
004C EF                MOV     A,R7
004D 5404              ANL     A,#04H
004F FF                MOV     R7,A
0050 7E00              MOV     R6,#00H
0052 EF                MOV     A,R7
0053 4E                ORL     A,R6
0054 700C              JNZ     ?C0051
                                           ; SOURCE LINE # 1126
                                           ; SOURCE LINE # 1128
0056 900000      R     MOV     DPTR,#txDataByte
0059 E0                MOVX    A,@DPTR
005A FF                MOV     R7,A
005B 906547            MOV     DPTR,#06547H
005E EF                MOV     A,R7
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1129
0060 802C              SJMP    ?C0052
0062         ?C0051:
                                           ; SOURCE LINE # 1131
                                           ; SOURCE LINE # 1132
0062 900000      R     MOV     DPTR,#UART_txBufferWrite
0065 E0                MOVX    A,@DPTR
0066 FF                MOV     R7,A
0067 EF                MOV     A,R7
0068 C3                CLR     C
0069 9420              SUBB    A,#020H
006B 4005              JC      ?C0053
                                           ; SOURCE LINE # 1133
                                           ; SOURCE LINE # 1134
006D 900000      R     MOV     DPTR,#UART_txBufferWrite
0070 E4                CLR     A
0071 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1135
0072         ?C0053:
                                           ; SOURCE LINE # 1137
0072 900000      R     MOV     DPTR,#txDataByte
0075 E0                MOVX    A,@DPTR
0076 FF                MOV     R7,A
0077 900000      R     MOV     DPTR,#UART_txBufferWrite
007A E0                MOVX    A,@DPTR
007B FE                MOV     R6,A
007C 7400        R     MOV     A,#LOW UART_txBuffer
007E 2E                ADD     A,R6
007F F582              MOV     DPL,A
0081 E4                CLR     A
0082 3400        R     ADDC    A,#HIGH UART_txBuffer
0084 F583              MOV     DPH,A
0086 EF                MOV     A,R7
0087 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1140
0088 900000      R     MOV     DPTR,#UART_txBufferWrite
008B E0                MOVX    A,@DPTR
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 45  

008C 04                INC     A
008D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1142
008E         ?C0052:
                                           ; SOURCE LINE # 1146
008E 120000      R     LCALL   UART_EnableTxInt
                                           ; SOURCE LINE # 1158
0091 22                RET     
             ; FUNCTION _UART_PutChar (END)

             ; FUNCTION _UART_PutString (BEGIN)
                                           ; SOURCE LINE # 1187
0000 900000      R     MOV     DPTR,#string
0003 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1188
                                           ; SOURCE LINE # 1190
0006 900000      R     MOV     DPTR,#UART_initVar
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
000B EF                MOV     A,R7
000C 6020              JZ      ?C0058
                                           ; SOURCE LINE # 1191
000E         ?C0056:
                                           ; SOURCE LINE # 1193
000E 900000      R     MOV     DPTR,#string
0011 120000      E     LCALL   ?C?PLDXDATA
0014 120000      E     LCALL   ?C?CLDPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 6013              JZ      ?C0058
                                           ; SOURCE LINE # 1194
                                           ; SOURCE LINE # 1195
001B 900000      R     MOV     DPTR,#string
001E E4                CLR     A
001F 75F001            MOV     B,#01H
0022 120000      E     LCALL   ?C?PLDIXDATA
0025 120000      E     LCALL   ?C?CLDPTR
0028 FF                MOV     R7,A
0029 120000      R     LCALL   _UART_PutChar
                                           ; SOURCE LINE # 1196
002C 80E0              SJMP    ?C0056
                                           ; SOURCE LINE # 1197
                                           ; SOURCE LINE # 1198
002E         ?C0058:
002E 22                RET     
             ; FUNCTION _UART_PutString (END)

             ; FUNCTION _UART_PutArray (BEGIN)
                                           ; SOURCE LINE # 1223
0000 900000      R     MOV     DPTR,#string
0003 120000      E     LCALL   ?C?PSTXDATA
0006 900000      R     MOV     DPTR,#byteCount
0009 ED                MOV     A,R5
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1225
                                           ; SOURCE LINE # 1227
000B 900000      R     MOV     DPTR,#UART_initVar
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 6024              JZ      ?C0062
                                           ; SOURCE LINE # 1228
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 46  

0013         ?C0060:
                                           ; SOURCE LINE # 1229
0013 900000      R     MOV     DPTR,#byteCount
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 D3                SETB    C
001A 9400              SUBB    A,#00H
001C 4019              JC      ?C0062
                                           ; SOURCE LINE # 1230
                                           ; SOURCE LINE # 1231
001E 900000      R     MOV     DPTR,#string
0021 E4                CLR     A
0022 75F001            MOV     B,#01H
0025 120000      E     LCALL   ?C?PLDIXDATA
0028 120000      E     LCALL   ?C?CLDPTR
002B FF                MOV     R7,A
002C 120000      R     LCALL   _UART_PutChar
                                           ; SOURCE LINE # 1232
002F 900000      R     MOV     DPTR,#byteCount
0032 E0                MOVX    A,@DPTR
0033 14                DEC     A
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1233
0035 80DC              SJMP    ?C0060
                                           ; SOURCE LINE # 1234
                                           ; SOURCE LINE # 1235
0037         ?C0062:
0037 22                RET     
             ; FUNCTION _UART_PutArray (END)

             ; FUNCTION _UART_PutCRLF (BEGIN)
                                           ; SOURCE LINE # 1259
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1260
                                           ; SOURCE LINE # 1262
0005 900000      R     MOV     DPTR,#UART_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 6012              JZ      ?C0064
                                           ; SOURCE LINE # 1263
                                           ; SOURCE LINE # 1264
000D 900000      R     MOV     DPTR,#txDataByte
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 120000      R     LCALL   _UART_PutChar
                                           ; SOURCE LINE # 1265
0015 7F0D              MOV     R7,#0DH
0017 120000      R     LCALL   _UART_PutChar
                                           ; SOURCE LINE # 1266
001A 7F0A              MOV     R7,#0AH
001C 120000      R     LCALL   _UART_PutChar
                                           ; SOURCE LINE # 1267
                                           ; SOURCE LINE # 1268
001F         ?C0064:
001F 22                RET     
             ; FUNCTION _UART_PutCRLF (END)

             ; FUNCTION UART_GetTxBufferSize (BEGIN)
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 47  

                                           ; SOURCE LINE # 1296
                                           ; SOURCE LINE # 1298
                                           ; SOURCE LINE # 1306
0000 120000      R     LCALL   UART_DisableTxInt
                                           ; SOURCE LINE # 1309
0003 900000      R     MOV     DPTR,#UART_txBufferWrite
0006 E0                MOVX    A,@DPTR
0007 FF                MOV     R7,A
0008 900000      R     MOV     DPTR,#UART_txBufferRead
000B E0                MOVX    A,@DPTR
000C FE                MOV     R6,A
000D EE                MOV     A,R6
000E B50707            CJNE    A,AR7,?C0065
                                           ; SOURCE LINE # 1310
                                           ; SOURCE LINE # 1311
0011 900000      R     MOV     DPTR,#size
0014 E4                CLR     A
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1312
0016 803B              SJMP    ?C0066
0018         ?C0065:
                                           ; SOURCE LINE # 1313
0018 900000      R     MOV     DPTR,#UART_txBufferWrite
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D 900000      R     MOV     DPTR,#UART_txBufferRead
0020 E0                MOVX    A,@DPTR
0021 FE                MOV     R6,A
0022 EE                MOV     A,R6
0023 C3                CLR     C
0024 9F                SUBB    A,R7
0025 5015              JNC     ?C0067
                                           ; SOURCE LINE # 1314
                                           ; SOURCE LINE # 1315
0027 900000      R     MOV     DPTR,#UART_txBufferRead
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C 900000      R     MOV     DPTR,#UART_txBufferWrite
002F E0                MOVX    A,@DPTR
0030 FE                MOV     R6,A
0031 C3                CLR     C
0032 EE                MOV     A,R6
0033 9F                SUBB    A,R7
0034 FF                MOV     R7,A
0035 900000      R     MOV     DPTR,#size
0038 EF                MOV     A,R7
0039 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1316
003A 8017              SJMP    ?C0066
003C         ?C0067:
                                           ; SOURCE LINE # 1318
                                           ; SOURCE LINE # 1319
003C 900000      R     MOV     DPTR,#UART_txBufferRead
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 C3                CLR     C
0042 7420              MOV     A,#020H
0044 9F                SUBB    A,R7
0045 FF                MOV     R7,A
0046 900000      R     MOV     DPTR,#UART_txBufferWrite
0049 E0                MOVX    A,@DPTR
004A FE                MOV     R6,A
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 48  

004B EF                MOV     A,R7
004C 2E                ADD     A,R6
004D FF                MOV     R7,A
004E 900000      R     MOV     DPTR,#size
0051 EF                MOV     A,R7
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1320
0053         ?C0066:
                                           ; SOURCE LINE # 1324
0053 120000      R     LCALL   UART_EnableTxInt
                                           ; SOURCE LINE # 1348
0056 900000      R     MOV     DPTR,#size
0059 E0                MOVX    A,@DPTR
005A FF                MOV     R7,A
                                           ; SOURCE LINE # 1349
005B         ?C0069:
005B 22                RET     
             ; FUNCTION UART_GetTxBufferSize (END)

             ; FUNCTION UART_ClearTxBuffer (BEGIN)
                                           ; SOURCE LINE # 1382
                                           ; SOURCE LINE # 1383
                                           ; SOURCE LINE # 1387
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1389
0008 906597            MOV     DPTR,#06597H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1390
0013 906597            MOV     DPTR,#06597H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FE              ANL     A,#0FEH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1392
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1399
0026 120000      R     LCALL   UART_DisableTxInt
                                           ; SOURCE LINE # 1402
0029 900000      R     MOV     DPTR,#UART_txBufferRead
002C E4                CLR     A
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1403
002E 900000      R     MOV     DPTR,#UART_txBufferWrite
0031 E4                CLR     A
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1407
0033 120000      R     LCALL   UART_EnableTxInt
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 49  

                                           ; SOURCE LINE # 1411
0036 22                RET     
             ; FUNCTION UART_ClearTxBuffer (END)

             ; FUNCTION _UART_SendBreak (BEGIN)
                                           ; SOURCE LINE # 1471
0000 900000      R     MOV     DPTR,#retMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1472
                                           ; SOURCE LINE # 1475
0005 900000      R     MOV     DPTR,#UART_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 7003              JNZ     $ + 5H
000D 020000      R     LJMP    ?C0086
                                           ; SOURCE LINE # 1476
                                           ; SOURCE LINE # 1519
0010 900000      R     MOV     DPTR,#retMode
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 600A              JZ      ?C0074
0018 900000      R     MOV     DPTR,#retMode
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 6403              XRL     A,#03H
0020 7028              JNZ     ?C0072
                                           ; SOURCE LINE # 1521
                                           ; SOURCE LINE # 1523
                                           ; SOURCE LINE # 1525
                                           ; SOURCE LINE # 1526
                                           ; SOURCE LINE # 1528
0022         ?C0074:
                                           ; SOURCE LINE # 1531
0022 906437            MOV     DPTR,#06437H
0025 E0                MOVX    A,@DPTR
0026 FF                MOV     R7,A
0027 900000      R     MOV     DPTR,#tx_period
002A EF                MOV     A,R7
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1532
002C 906437            MOV     DPTR,#06437H
002F 74CF              MOV     A,#0CFH
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1539
0032 906547            MOV     DPTR,#06547H
0035 E4                CLR     A
0036 F0                MOVX    @DPTR,A
0037         ?C0077:
                                           ; SOURCE LINE # 1542
                                           ; SOURCE LINE # 1543
0037 906467            MOV     DPTR,#06467H
003A E0                MOVX    A,@DPTR
003B FF                MOV     R7,A
003C 900000      R     MOV     DPTR,#tmpStat
003F EF                MOV     A,R7
0040 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1544
0041 900000      R     MOV     DPTR,#tmpStat
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 50  

0044 E0                MOVX    A,@DPTR
0045 FF                MOV     R7,A
0046 EF                MOV     A,R7
0047 20E1ED            JB      ACC.1,?C0077
                                           ; SOURCE LINE # 1545
004A         ?C0072:
                                           ; SOURCE LINE # 1547
004A 900000      R     MOV     DPTR,#retMode
004D E0                MOVX    A,@DPTR
004E FF                MOV     R7,A
004F EF                MOV     A,R7
0050 6401              XRL     A,#01H
0052 6009              JZ      ?C0082
0054 900000      R     MOV     DPTR,#retMode
0057 E0                MOVX    A,@DPTR
0058 FF                MOV     R7,A
0059 EF                MOV     A,R7
005A B40318            CJNE    A,#03H,?C0078
                                           ; SOURCE LINE # 1549
005D         ?C0082:
                                           ; SOURCE LINE # 1551
                                           ; SOURCE LINE # 1552
005D 906467            MOV     DPTR,#06467H
0060 E0                MOVX    A,@DPTR
0061 FF                MOV     R7,A
0062 900000      R     MOV     DPTR,#tmpStat
0065 EF                MOV     A,R7
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1553
0067 900000      R     MOV     DPTR,#tmpStat
006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
006C EF                MOV     A,R7
006D F4                CPL     A
006E FF                MOV     R7,A
006F 7E00              MOV     R6,#00H
0071 EF                MOV     A,R7
0072 20E0E8            JB      ACC.0,?C0082
                                           ; SOURCE LINE # 1554
0075         ?C0078:
                                           ; SOURCE LINE # 1556
0075 900000      R     MOV     DPTR,#retMode
0078 E0                MOVX    A,@DPTR
0079 FF                MOV     R7,A
007A EF                MOV     A,R7
007B 6401              XRL     A,#01H
007D 6013              JZ      ?C0084
007F 900000      R     MOV     DPTR,#retMode
0082 E0                MOVX    A,@DPTR
0083 FF                MOV     R7,A
0084 EF                MOV     A,R7
0085 6402              XRL     A,#02H
0087 6009              JZ      ?C0084
0089 900000      R     MOV     DPTR,#retMode
008C E0                MOVX    A,@DPTR
008D FF                MOV     R7,A
008E EF                MOV     A,R7
008F B4030A            CJNE    A,#03H,?C0086
0092         ?C0084:
                                           ; SOURCE LINE # 1559
                                           ; SOURCE LINE # 1562
0092 900000      R     MOV     DPTR,#tx_period
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 51  

0095 E0                MOVX    A,@DPTR
0096 FF                MOV     R7,A
0097 906437            MOV     DPTR,#06437H
009A EF                MOV     A,R7
009B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1567
                                           ; SOURCE LINE # 1569
                                           ; SOURCE LINE # 1570
                                           ; SOURCE LINE # 1572
                                           ; SOURCE LINE # 1573
                                           ; SOURCE LINE # 1575
                                           ; SOURCE LINE # 1576
009C         ?C0086:
009C 22                RET     
             ; FUNCTION _UART_SendBreak (END)

             ; FUNCTION _UART_SetTxAddressMode (BEGIN)
                                           ; SOURCE LINE # 1594
0000 900000      R     MOV     DPTR,#addressMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1595
                                           ; SOURCE LINE # 1597
0005 900000      R     MOV     DPTR,#addressMode
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 600B              JZ      ?C0087
                                           ; SOURCE LINE # 1598
                                           ; SOURCE LINE # 1599
000D 120000      R     LCALL   UART_ReadControlRegister
0010 EF                MOV     A,R7
0011 4404              ORL     A,#04H
0013 FF                MOV     R7,A
0014 120000      R     LCALL   _UART_WriteControlRegister
                                           ; SOURCE LINE # 1600
0017 22                RET     
0018         ?C0087:
                                           ; SOURCE LINE # 1602
                                           ; SOURCE LINE # 1603
0018 120000      R     LCALL   UART_ReadControlRegister
001B EF                MOV     A,R7
001C 54FB              ANL     A,#0FBH
001E FF                MOV     R7,A
001F 120000      R     LCALL   _UART_WriteControlRegister
                                           ; SOURCE LINE # 1604
                                           ; SOURCE LINE # 1605
0022         ?C0089:
0022 22                RET     
             ; FUNCTION _UART_SetTxAddressMode (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1571    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     72      29
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
C51 COMPILER V9.03   UART                                                                  09/24/2013 19:16:36 PAGE 52  

   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
